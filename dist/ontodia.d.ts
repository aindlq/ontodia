// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../../react

declare module 'ontodia' {
    export * from 'ontodia/ontodia/customization/props';
    export * from 'ontodia/ontodia/customization/templates';
    export * from 'ontodia/ontodia/data/model';
    export * from 'ontodia/ontodia/data/metadataApi';
    export * from 'ontodia/ontodia/data/validationApi';
    export * from 'ontodia/ontodia/data/provider';
    export * from 'ontodia/ontodia/data/demo/provider';
    export { RdfNode, RdfIri, RdfLiteral, Triple } from 'ontodia/ontodia/data/sparql/sparqlModels';
    export * from 'ontodia/ontodia/data/rdf/rdfDataProvider';
    export * from 'ontodia/ontodia/data/sparql/sparqlDataProvider';
    export * from 'ontodia/ontodia/data/composite/composite';
    export * from 'ontodia/ontodia/data/sparql/sparqlDataProviderSettings';
    export * from 'ontodia/ontodia/data/sparql/graphBuilder';
    export * from 'ontodia/ontodia/data/sparql/sparqlGraphBuilder';
    export { DIAGRAM_CONTEXT_URL_V1 } from 'ontodia/ontodia/data/schema';
    export { RestoreGeometry, setElementExpanded, setElementData, setLinkData } from 'ontodia/ontodia/diagram/commands';
    export { Element, ElementEvents, ElementTemplateState, Link, LinkEvents, LinkTemplateState, LinkVertex, Cell, LinkDirection } from 'ontodia/ontodia/diagram/elements';
    export { EmbeddedLayer } from 'ontodia/ontodia/diagram/embeddedLayer';
    export * from 'ontodia/ontodia/diagram/geometry';
    export * from 'ontodia/ontodia/diagram/history';
    export { DiagramModel, DiagramModelEvents } from 'ontodia/ontodia/diagram/model';
    export * from 'ontodia/ontodia/diagram/view';
    export { PointerEvent, PointerUpEvent, getContentFittingBox, ViewportOptions, ScaleOptions, } from 'ontodia/ontodia/diagram/paperArea';
    export * from 'ontodia/ontodia/editor/asyncModel';
    export { AuthoredEntity, AuthoredEntityProps, AuthoredEntityContext } from 'ontodia/ontodia/editor/authoredEntity';
    export * from 'ontodia/ontodia/editor/authoringState';
    export { EditorOptions, EditorEvents, EditorController, PropertyEditor, PropertyEditorOptions, } from 'ontodia/ontodia/editor/editorController';
    export { ValidationState, ElementValidation, LinkValidation } from 'ontodia/ontodia/editor/validation';
    export { LayoutData, LayoutElement, LayoutLink, SerializedDiagram, convertToSerializedDiagram, makeSerializedDiagram, LinkTypeOptions, makeLayoutData } from 'ontodia/ontodia/editor/serializedDiagram';
    export { calculateLayout, removeOverlaps, CalculatedLayout, UnzippedCalculatedLayout, LayoutNode, applyLayout, forceLayout, } from 'ontodia/ontodia/viewUtils/layout';
    export { Cancellation, CancellationToken } from 'ontodia/ontodia/viewUtils/async';
    export * from 'ontodia/ontodia/viewUtils/events';
    export { PropertySuggestionParams, PropertyScore } from 'ontodia/ontodia/widgets/connectionsMenu';
    export { DefaultToolbar, ToolbarProps } from 'ontodia/ontodia/workspace/toolbar';
    export { Workspace, WorkspaceProps, WorkspaceState, WorkspaceLanguage, renderTo, } from 'ontodia/ontodia/workspace/workspace';
    export { WorkspaceEventHandler, WorkspaceEventKey } from 'ontodia/ontodia/workspace/workspaceContext';
    export { DraggableHandle } from 'ontodia/ontodia/workspace/draggableHandle';
    export * from 'ontodia/ontodia/workspace/layout/layout';
    import * as InternalApi from 'ontodia/internalApi';
    export { InternalApi };
}

declare module 'ontodia/ontodia/customization/props' {
    import { ComponentClass } from 'react';
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { ElementIri, ElementModel, Dictionary, LocalizedString, Property } from 'ontodia/ontodia/data/model';
    import { Link } from 'ontodia/ontodia/diagram/elements';
    export type TypeStyleResolver = (types: string[]) => CustomTypeStyle | undefined;
    export type LinkTemplateResolver = (linkType: string) => LinkTemplate | undefined;
    export type TemplateResolver = (types: string[]) => ElementTemplate | undefined;
    export interface CustomTypeStyle {
        color?: string;
        icon?: string;
    }
    export type ElementTemplate = ComponentClass<TemplateProps>;
    export interface TemplateProps {
        elementId: string;
        data: ElementModel;
        iri: ElementIri;
        types: string;
        label: string;
        color: any;
        iconUrl: string;
        imgUrl?: string;
        isExpanded?: boolean;
        propsAsList?: PropArray;
        props?: Dictionary<Property>;
    }
    export type PropArray = Array<{
        id: string;
        name: string;
        property: Property;
    }>;
    export interface LinkTemplate {
        markerSource?: LinkMarkerStyle;
        markerTarget?: LinkMarkerStyle;
        renderLink?(link: Link): LinkStyle;
        setLinkLabel?: (link: Link, label: string) => void;
    }
    export interface LinkStyle {
        connection?: {
            fill?: string;
            stroke?: string;
            'stroke-width'?: number;
            'stroke-dasharray'?: string;
        };
        label?: LinkLabel;
        properties?: LinkLabel[];
        connector?: {
            name?: string;
            args?: {};
        };
    }
    export interface LinkRouter {
        route(model: DiagramModel): RoutedLinks;
    }
    export type RoutedLinks = Map<string, RoutedLink>;
    export interface RoutedLink {
        linkId: string;
        vertices: ReadonlyArray<Vertex>;
        labelTextAnchor?: 'start' | 'middle' | 'end';
    }
    export interface Vertex {
        x: number;
        y: number;
    }
    export interface LinkMarkerStyle {
        fill?: string;
        stroke?: string;
        strokeWidth?: string;
        d?: string;
        width?: number;
        height?: number;
    }
    export interface LinkLabel {
        position?: number;
        title?: string;
        attrs?: {
            rect?: {
                fill?: string;
                stroke?: string;
                'stroke-width'?: number;
            };
            text?: {
                fill?: string;
                stroke?: string;
                'stroke-width'?: number;
                'font-family'?: string;
                'font-size'?: string | number;
                'font-weight'?: 'normal' | 'bold' | 'lighter' | 'bolder' | number;
                text?: LocalizedString[];
            };
        };
    }
}

declare module 'ontodia/ontodia/customization/templates' {
    import { TemplateResolver } from 'ontodia/ontodia/customization/props';
    export * from 'ontodia/ontodia/customization/templates/default';
    export * from 'ontodia/ontodia/customization/templates/group';
    export * from 'ontodia/ontodia/customization/templates/standard';
    export const DefaultElementTemplateBundle: TemplateResolver;
}

declare module 'ontodia/ontodia/data/model' {
    import { RdfIri } from 'ontodia/ontodia/data/sparql/sparqlModels';
    export interface Dictionary<T> {
        [key: string]: T;
    }
    export interface LocalizedString {
        readonly value: string;
        readonly language: string;
        /** Equals `xsd:string` if not defined. */
        readonly datatype?: {
            readonly value: string;
        };
    }
    export interface IriProperty {
        type: 'uri';
        values: ReadonlyArray<RdfIri>;
    }
    export interface LiteralProperty {
        type: 'string';
        values: ReadonlyArray<LocalizedString>;
    }
    export type Property = IriProperty | LiteralProperty;
    export function isIriProperty(e: Property): e is IriProperty;
    export function isLiteralProperty(e: Property): e is LiteralProperty;
    export type ElementIri = string & {
        readonly elementBrand: void;
    };
    export type ElementTypeIri = string & {
        readonly classBrand: void;
    };
    export type LinkTypeIri = string & {
        readonly linkTypeBrand: void;
    };
    export type PropertyTypeIri = string & {
        readonly propertyTypeBrand: void;
    };
    export interface ElementModel {
        id: ElementIri;
        types: ElementTypeIri[];
        label: {
            values: LocalizedString[];
        };
        image?: string;
        properties: {
            [id: string]: Property;
        };
        sources?: string[];
    }
    export interface LinkModel {
        linkTypeId: LinkTypeIri;
        sourceId: ElementIri;
        targetId: ElementIri;
        properties?: {
            [id: string]: Property;
        };
    }
    export interface ClassModel {
        id: ElementTypeIri;
        label: {
            values: LocalizedString[];
        };
        count?: number;
        children: ClassModel[];
    }
    export interface LinkCount {
        id: LinkTypeIri;
        inCount: number;
        outCount: number;
    }
    export interface LinkType {
        id: LinkTypeIri;
        label: {
            values: LocalizedString[];
        };
        count?: number;
    }
    export interface PropertyModel {
        id: PropertyTypeIri;
        label: {
            values: LocalizedString[];
        };
    }
    export function sameLink(left: LinkModel, right: LinkModel): boolean;
    export function hashLink(link: LinkModel): number;
    export function sameElement(left: ElementModel, right: ElementModel): boolean;
}

declare module 'ontodia/ontodia/data/metadataApi' {
    import { ElementModel, ElementTypeIri, LinkTypeIri, PropertyTypeIri, LinkModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { LinkDirection } from 'ontodia/ontodia/diagram/elements';
    import { CancellationToken } from 'ontodia/ontodia/viewUtils/async';
    export interface MetadataApi {
            /**
                * Can user create element and link from this element?
                */
            canDropOnCanvas(source: ElementModel, ct: CancellationToken): Promise<boolean>;
            /**
                * Can we create link between two elements? Maybe it's unnesesary.
                */
            canDropOnElement(source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<boolean>;
            /**
                * Links of which types can we create between elements?
                */
            possibleLinkTypes(source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<Array<{
                    linkTypeIri: LinkTypeIri;
                    direction: LinkDirection;
            }>>;
            /**
                * If new element is created by dragging link from existing element, this should return available element types.
                */
            typesOfElementsDraggedFrom(source: ElementModel, ct: CancellationToken): Promise<ElementTypeIri[]>;
            /**
                * List properties for type meant to be edited in-place.
                */
            propertiesForType(type: ElementTypeIri, ct: CancellationToken): Promise<PropertyTypeIri[]>;
            filterConstructibleTypes(types: ReadonlySet<ElementTypeIri>, ct: CancellationToken): Promise<ReadonlySet<ElementTypeIri>>;
            canDeleteElement(element: ElementModel, ct: CancellationToken): Promise<boolean>;
            canEditElement(element: ElementModel, ct: CancellationToken): Promise<boolean>;
            canLinkElement(element: ElementModel, ct: CancellationToken): Promise<boolean>;
            canDeleteLink(link: LinkModel, source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<boolean>;
            canEditLink(link: LinkModel, source: ElementModel, target: ElementModel, ct: CancellationToken): Promise<boolean>;
            generateNewElementIri(types: ReadonlyArray<ElementTypeIri>, ct: CancellationToken): Promise<ElementIri>;
    }
    export interface DirectedLinkType {
            readonly linkTypeIri: LinkTypeIri;
            readonly direction: LinkDirection;
    }
}

declare module 'ontodia/ontodia/data/validationApi' {
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { AuthoringState } from 'ontodia/ontodia/editor/authoringState';
    import { CancellationToken } from 'ontodia/ontodia/viewUtils/async';
    import { ElementModel, LinkModel, ElementIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    export interface ElementError {
        readonly type: 'element';
        readonly target: ElementIri;
        readonly message: string;
        readonly propertyType?: PropertyTypeIri;
    }
    export interface LinkError {
        readonly type: 'link';
        readonly target: LinkModel;
        readonly message: string;
    }
    export interface ValidationEvent {
        readonly target: ElementModel;
        readonly outboundLinks: ReadonlyArray<LinkModel>;
        readonly model: DiagramModel;
        readonly state: AuthoringState;
        readonly cancellation: CancellationToken;
    }
    export interface ValidationApi {
        /**
          * Validate element and its outbound links.
          */
        validate(e: ValidationEvent): Promise<Array<ElementError | LinkError>>;
    }
}

declare module 'ontodia/ontodia/data/provider' {
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, PropertyModel, ElementIri, ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    /**
        * DataProvider is responsible for getting data into Ontodia
        *
        * It has three parts:
        *  - Schema extraction - classTree(), linkTypes()
        *  - On-demand schema extraction - classInfo(), propertyInfo(), linkTypeInfo()
        *  - elements and links extraction - elementsInfo() and linksInfo()
        *  - navigation - linkTypesOf(), linkElements()
        *  - filtering - filter
        *
        *  Schema extraction is executed on initialization and used to display class tree.
        *
        *  On-demand schema extraction occurs when element with yet unknown type or link type appears any part of Ontodia.
        *
        *  Elements and links extraction is executed when new element is placed on the diagram or diagram is restored from
        *  saved state to get all the data for it
        *
        *  Navigation functions are called when user brings up navigation menu to display available links
        *  and places chosen elements on the diagram.
        *
        *  When possible, Ontodia will group requests into batches to reduce round-trips and this will reduce calls to
        *  data provider.
        *
        */
    export interface DataProvider {
            /** should return start-up class tree. In case of huge class tree some limits should be imposed.
                * It can contain count of instances for each class if it's possible to get it from source.
                */
            classTree(): Promise<ClassModel[]>;
            linkTypes(): Promise<LinkType[]>;
            /**
                * Class information
                */
            classInfo(params: {
                    classIds: ElementTypeIri[];
            }): Promise<ClassModel[]>;
            /**
                * Data properties information
                */
            propertyInfo?(params: {
                    propertyIds: PropertyTypeIri[];
            }): Promise<Dictionary<PropertyModel>>;
            /**
                * Link type information.
                */
            linkTypesInfo(params: {
                    linkTypeIds: LinkTypeIri[];
            }): Promise<LinkType[]>;
            /**
                * Getting the elements from the data source on diagram initialization and on navigation events
                */
            elementInfo(params: {
                    elementIds: ElementIri[];
            }): Promise<Dictionary<ElementModel>>;
            /**
                * Should return all links between elements.
                * linkTypeIds is ignored in current sparql providers and is subject to be removed
                */
            linksInfo(params: {
                    elementIds: ElementIri[];
                    linkTypeIds: LinkTypeIri[];
            }): Promise<LinkModel[]>;
            /**
                * Get link types of element to build navigation menu
                */
            linkTypesOf(params: {
                    elementId: ElementIri;
            }): Promise<LinkCount[]>;
            /**
                * returns elements following link for specified element.
                * Has overlapping functionality with filter, but easier less powerful and easier to implement
                * linkId could be null, if it's the case method should return all elements from all links from current element.
                */
            linkElements(params: LinkElementsParams): Promise<Dictionary<ElementModel>>;
            /**
                * Supports filter functionality with different filters - by type,
                * by element and it's connection, by full-text search.
                * Implementation should implement all possible combinations.
                */
            filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
    }
    export interface LinkElementsParams {
            elementId: ElementIri;
            linkId: LinkTypeIri;
            limit?: number;
            offset: number;
            direction?: 'in' | 'out';
    }
    export interface FilterParams {
            /**
                * element type filter
                */
            elementTypeId?: ElementTypeIri;
            /**
                * text search
                */
            text?: string;
            /**
                * Reference element id to limit elements accessible through links from this elements only.
                * Could be used with refElementLinkId to limit link types which to follow.
                */
            refElementId?: ElementIri;
            /**
                * Reference element link type id. Is used only when refElementId is set.
                */
            refElementLinkId?: LinkTypeIri;
            /**
                * Reference element link type direction ('in' | 'out'). Is used only when refElementLinkId is set.
                */
            linkDirection?: 'in' | 'out';
            /**
                * Limit number of elements returned. Defaults depend on data provider implementation
                */
            limit?: number;
            /**
                * Offset within matched data set to use
                */
            offset: number;
            /**
                * Right now this is unused in sparql data provider.
                * It was introduced to order results by particular language when doing substring match with regexps.
                * It's subject to be removed.
                */
            languageCode: string;
    }
}

declare module 'ontodia/ontodia/data/demo/provider' {
    import { DataProvider, LinkElementsParams, FilterParams } from 'ontodia/ontodia/data/provider';
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, ElementIri, ElementTypeIri, LinkTypeIri } from 'ontodia/ontodia/data/model';
    export class DemoDataProvider implements DataProvider {
        constructor(allClasses: ClassModel[], allLinkTypes: LinkType[], allElements: Dictionary<ElementModel>, allLinks: LinkModel[]);
        classTree(): Promise<ClassModel[]>;
        classInfo(params: {
            classIds: ElementTypeIri[];
        }): Promise<ClassModel[]>;
        linkTypes(): Promise<LinkType[]>;
        linkTypesInfo(params: {
            linkTypeIds: LinkTypeIri[];
        }): Promise<LinkType[]>;
        elementInfo(params: {
            elementIds: ElementIri[];
        }): Promise<Dictionary<ElementModel>>;
        linksInfo(params: {
            elementIds: ElementIri[];
            linkTypeIds: LinkTypeIri[];
        }): Promise<LinkModel[]>;
        linkTypesOf(params: {
            elementId: ElementIri;
        }): Promise<LinkCount[]>;
        linkElements(params: LinkElementsParams): Promise<Dictionary<ElementModel>>;
        filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
    }
}

declare module 'ontodia/ontodia/data/sparql/sparqlModels' {
    export type RdfNode = RdfIri | RdfLiteral | RdfBlank;
    export interface RdfIri {
        type: 'uri';
        value: string;
    }
    export interface RdfBlank {
        type: 'bnode';
        value: string;
    }
    export interface RdfLiteral {
        type: 'literal';
        value: string;
        datatype?: string;
        'xml:lang': string;
    }
    export interface Triple {
        subject: RdfNode;
        predicate: RdfNode;
        object: RdfNode;
    }
    export function isRdfBlank(e: RdfNode): e is RdfBlank;
    export function isRdfIri(e: RdfNode): e is RdfIri;
    export function isRdfLiteral(e: RdfNode): e is RdfLiteral;
    export interface BlankBinding extends ElementBinding {
        blankType: {
            value: 'listHead' | 'blankNode';
        };
        blankTrgProp: RdfNode;
        blankTrg: RdfNode;
        blankSrc?: RdfNode;
        blankSrcProp?: RdfNode;
        newInst?: RdfIri | RdfBlank;
    }
    export function isBlankBinding(binding: ElementBinding | BlankBinding): binding is BlankBinding;
    export interface ElementBinding {
        inst: RdfIri | RdfBlank;
        class?: RdfIri;
        label?: RdfLiteral;
        propType?: RdfIri;
        propValue?: RdfIri | RdfLiteral;
    }
    export interface ClassBinding {
        class: RdfIri;
        instcount?: RdfLiteral;
        label?: RdfLiteral;
        parent?: RdfIri;
    }
    export interface PropertyBinding {
        property: RdfIri;
        label?: RdfLiteral;
    }
    export interface LinkBinding {
        source: RdfIri | RdfBlank;
        type: RdfIri;
        target: RdfIri | RdfBlank;
        propType?: RdfIri;
        propValue?: RdfLiteral;
    }
    export interface LinkCountBinding {
        link: RdfIri | RdfBlank;
        inCount: RdfLiteral;
        outCount: RdfLiteral;
    }
    export interface LinkTypeBinding {
        link: RdfIri;
        label?: RdfLiteral;
        instcount?: RdfLiteral;
    }
    export interface ElementImageBinding {
        inst: RdfIri;
        linkType: RdfIri;
        image: RdfIri;
    }
    export interface ElementTypeBinding {
        inst: RdfIri;
        class: RdfIri;
    }
    export interface FilterBinding {
        classAll?: RdfIri;
        link?: RdfIri;
        direction?: RdfLiteral;
    }
    export interface SparqlResponse<Binding> {
        head: {
            vars: string[];
        };
        results: {
            bindings: Binding[];
        };
    }
}

declare module 'ontodia/ontodia/data/rdf/rdfDataProvider' {
    import { DataProvider, LinkElementsParams, FilterParams } from 'ontodia/ontodia/data/provider';
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, PropertyModel, ElementIri, ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    export interface RDFFile {
        content: string;
        fileName?: string;
        type?: string;
        uri?: string;
    }
    export interface RDFDataProviderOptions {
        data: RDFFile[];
        parsers: {
            [id: string]: any;
        };
        acceptBlankNodes?: boolean;
        dataFetching?: boolean;
        proxy?: string;
    }
    /** An opaque reference to RDFGraph type from `rdf-ext` library */
    export type RDFExtGraph = object;
    export class RDFDataProvider implements DataProvider {
        dataFetching: boolean;
        readonly options: RDFDataProviderOptions;
        constructor(options: RDFDataProviderOptions);
        addGraph(graph: RDFExtGraph): void;
        classTree(): Promise<ClassModel[]>;
        propertyInfo(params: {
            propertyIds: PropertyTypeIri[];
        }): Promise<Dictionary<PropertyModel>>;
        classInfo(params: {
            classIds: ElementTypeIri[];
        }): Promise<ClassModel[]>;
        linkTypesInfo(params: {
            linkTypeIds: LinkTypeIri[];
        }): Promise<LinkType[]>;
        linkTypes(): Promise<LinkType[]>;
        elementInfo(params: {
            elementIds: ElementIri[];
        }): Promise<Dictionary<ElementModel>>;
        linksInfo(params: {
            elementIds: ElementIri[];
            linkTypeIds: LinkTypeIri[];
        }): Promise<LinkModel[]>;
        linkTypesOf(params: {
            elementId: ElementIri;
        }): Promise<LinkCount[]>;
        linkElements(params: LinkElementsParams): Promise<Dictionary<ElementModel>>;
        filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
    }
}

declare module 'ontodia/ontodia/data/sparql/sparqlDataProvider' {
    import { DataProvider, LinkElementsParams, FilterParams } from 'ontodia/ontodia/data/provider';
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, PropertyModel, ElementIri, ElementTypeIri, LinkTypeIri, PropertyTypeIri, LocalizedString } from 'ontodia/ontodia/data/model';
    import { SparqlResponse, Triple } from 'ontodia/ontodia/data/sparql/sparqlModels';
    import { SparqlDataProviderSettings } from 'ontodia/ontodia/data/sparql/sparqlDataProviderSettings';
    export enum SparqlQueryMethod {
            GET = 1,
            POST = 2
    }
    export type QueryFunction = (params: {
            url: string;
            body?: string;
            headers: {
                    [header: string]: string;
            };
            method: string;
    }) => Promise<Response>;
    /**
        * Runtime settings of SPARQL data provider
        */
    export interface SparqlDataProviderOptions {
            /**
                * If it's true then blank nodes will be present on the paper
                * By default blank nodes wont be shown
                */
            acceptBlankNodes?: boolean;
            /**
                *  sparql endpoint URL to use
                */
            endpointUrl: string;
            /**
                * properties to use as image URLs
                */
            imagePropertyUris?: string[];
            /**
                * Allows to extract/fetch image URLs externally instead of using `imagePropertyUris` option.
                */
            prepareImages?: (elementInfo: Dictionary<ElementModel>) => Promise<Dictionary<string>>;
            /**
                * Allows to extract/fetch labels separately from SPARQL query as an alternative or
                * in addition to `label` output binding.
                */
            prepareLabels?: (resources: Set<string>) => Promise<Map<string, LocalizedString[]>>;
            /**
                * wether to use GET (more compatible (Virtuozo), more error-prone due to large request URLs)
                * or POST(less compatible, better on large data sets)
                */
            queryMethod?: SparqlQueryMethod;
            queryFunction?: QueryFunction;
    }
    export class SparqlDataProvider implements DataProvider {
            readonly options: SparqlDataProviderOptions;
            readonly settings: SparqlDataProviderSettings;
            constructor(options: SparqlDataProviderOptions, settings?: SparqlDataProviderSettings);
            classTree(): Promise<ClassModel[]>;
            propertyInfo(params: {
                    propertyIds: PropertyTypeIri[];
            }): Promise<Dictionary<PropertyModel>>;
            classInfo(params: {
                    classIds: ElementTypeIri[];
            }): Promise<ClassModel[]>;
            linkTypesInfo(params: {
                    linkTypeIds: LinkTypeIri[];
            }): Promise<LinkType[]>;
            linkTypes(): Promise<LinkType[]>;
            elementInfo(params: {
                    elementIds: ElementIri[];
            }): Promise<Dictionary<ElementModel>>;
            linksInfo(params: {
                    elementIds: ElementIri[];
                    linkTypeIds: LinkTypeIri[];
            }): Promise<LinkModel[]>;
            linkTypesOf(params: {
                    elementId: ElementIri;
            }): Promise<LinkCount[]>;
            linkElements(params: LinkElementsParams): Promise<Dictionary<ElementModel>>;
            filter(baseParams: FilterParams): Promise<Dictionary<ElementModel>>;
            executeSparqlQuery<Binding>(query: string): Promise<SparqlResponse<Binding>>;
            executeSparqlConstruct(query: string): Promise<Triple[]>;
            protected createRefQueryPart(params: {
                    elementId: ElementIri;
                    linkId?: LinkTypeIri;
                    direction?: 'in' | 'out';
            }): string;
            formatLinkLinks(): string;
            formatLinkPath(path: string, source: string, target: string): string;
            formatPropertyInfo(): string;
            formatPropertyPath(path: string, subject: string, value: string): string;
    }
    export function executeSparqlQuery<Binding>(endpoint: string, query: string, method: SparqlQueryMethod, queryFunction: QueryFunction): Promise<SparqlResponse<Binding>>;
    export function executeSparqlConstruct(endpoint: string, query: string, method: SparqlQueryMethod, queryFunction: QueryFunction): Promise<Triple[]>;
}

declare module 'ontodia/ontodia/data/composite/composite' {
    import { DataProvider, LinkElementsParams, FilterParams } from 'ontodia/ontodia/data/provider';
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, PropertyModel, ElementIri, ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    export interface DPDefinition {
        name: string;
        dataProvider: DataProvider;
        useInStats?: boolean;
    }
    export type MergeMode = 'fetchAll' | 'sequentialFetching';
    export class CompositeDataProvider implements DataProvider {
        dataProviders: DPDefinition[];
        mergeMode: MergeMode;
        constructor(dataProviders: (DataProvider | DPDefinition)[], params?: {
            mergeMode?: MergeMode;
        });
        classTree(): Promise<ClassModel[]>;
        propertyInfo(params: {
            propertyIds: PropertyTypeIri[];
        }): Promise<Dictionary<PropertyModel>>;
        classInfo(params: {
            classIds: ElementTypeIri[];
        }): Promise<ClassModel[]>;
        linkTypesInfo(params: {
            linkTypeIds: LinkTypeIri[];
        }): Promise<LinkType[]>;
        linkTypes(): Promise<LinkType[]>;
        elementInfo(params: {
            elementIds: ElementIri[];
        }): Promise<Dictionary<ElementModel>>;
        linksInfo(params: {
            elementIds: ElementIri[];
            linkTypeIds: LinkTypeIri[];
        }): Promise<LinkModel[]>;
        linkTypesOf(params: {
            elementId: ElementIri;
        }): Promise<LinkCount[]>;
        linkElements(params: LinkElementsParams): Promise<Dictionary<ElementModel>>;
        filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
    }
}

declare module 'ontodia/ontodia/data/sparql/sparqlDataProviderSettings' {
    /**
        * Dataset-schema specific settings for SPARQL data provider.
        */
    export interface SparqlDataProviderSettings {
            /**
                * Default prefix to be used in every query.
                */
            defaultPrefix: string;
            /**
                * Property path for querying schema labels in schema (classes, link types, properties).
                */
            schemaLabelProperty: string;
            /**
                * Property path for querying instance data labels (elements, links).
                */
            dataLabelProperty: string;
            /**
                * Full-text search settings.
                */
            fullTextSearch: FullTextSearchSettings;
            /**
                * SELECT query to retreive class tree.
                *
                * Parametrized variables:
                *   - `${schemaLabelProperty}` `schemaLabelProperty` property from the settings
                *
                * Expected output bindings:
                *   - `?class`
                *   - `?label` (optional)
                *   - `?parent` (optional)
                *   - `?instcount` (optional)
                */
            classTreeQuery?: string;
            /**
                * SELECT query to retrieve data for each class in a set.
                *
                * Parametrized variables:
                *   - `${ids}` VALUES clause content with class IRIs
                *   - `${schemaLabelProperty}` `schemaLabelProperty` property from the settings
                *
                * Expected output bindings:
                *   - `?class`
                *   - `?label` (optional)
                *   - `?instcount` (optional)
                */
            classInfoQuery?: string;
            /**
                * SELECT query to retrieve initial link types.
                *
                * Parametrized variables:
                *   - `${linkTypesPattern}` `linkTypesPattern` property from the settings
                *   - `${schemaLabelProperty}` `schemaLabelProperty` property from the settings
                *
                * Expected output bindings:
                *   - `?link`
                *   - `?label` (optional)
                *   - `?instcount` (optional)
                */
            linkTypesQuery?: string;
            /**
                * Overridable part of `linkTypesQuery` with same output bindings.
                *
                * Parametrized variables: none
                */
            linkTypesPattern?: string;
            /**
                * SELECT query to retrieve data for each link type in a set.
                *
                * Parametrized variables:
                *   - `${ids}` VALUES clause content with link type IRIs
                *   - `${schemaLabelProperty}` `schemaLabelProperty` property from the settings
                *
                * Expected output bindings:
                *   - `?link`
                *   - `?label` (optional)
                *   - `?instcount` (optional)
                */
            linkTypesInfoQuery?: string;
            /**
                * SELECT query to retrieve data for each datatype property in a set.
                *
                * Parametrized variables:
                *   - `${ids}` VALUES clause content with datatype property IRIs
                *   - `${schemaLabelProperty}` `schemaLabelProperty` property from the settings
                *
                * Expected output bindings:
                *   - `?property`
                *   - `?label` (optional)
                */
            propertyInfoQuery?: string;
            /**
                * CONSTRUCT query to retrieve data for each element (types, labels, properties).
                *
                * Parametrized variables:
                *   - `${ids}` VALUES clause content with element IRIs
                *   - `${dataLabelProperty}` `dataLabelProperty` property from the settings
                *   - `${propertyConfigurations}`
                *
                * Expected output format for triples:
                *   - `?inst rdf:type ?class` element has type
                *   - `?inst rdfs:label ?label` element has label
                *   - `?inst ?property ?value` element has value for a datatype property
                */
            elementInfoQuery: string;
            /**
                * SELECT query to retrieve all links between specified elements.
                *
                * Parametrized variables:
                *   - `${ids}` VALUES clause content with element IRIs
                *   - `${linkConfigurations}`
                *
                * Expected output bindings:
                *   - `?type` link type
                *   - `?source` link source
                *   - `?target` link target
                *   - `?propType` (optional) link property type
                *   - `?propValue` (optional) link property value
                */
            linksInfoQuery: string;
            /**
                * Query pattern to retrieve image URL for an element.
                *
                * Expected bindings:
                *   - `?inst` element IRI
                *   - `?linkType` image property IRI
                *   - `?image` result image URL
                */
            imageQueryPattern: string;
            /**
                * SELECT query to retrieve incoming/outgoing link types from specified element with statistics.
                *
                * Parametrized variables:
                *   - `${elementIri}`
                *   - `${linkConfigurations}`
                *
                * Expected bindings:
                *   - `?link`
                *   - `?label` (optional)
                *   - `?instcount` (optional)
                */
            linkTypesOfQuery: string;
            /**
                * SELECT query to retrieve statistics of incoming/outgoing link types for specified element.
                *
                * Parametrized variables:
                *   - `${linkId}`
                *   - `${elementIri}`
                *   - `${linkConfigurationOut}`
                *   - `${linkConfigurationIn}`
                *   - `${navigateElementFilterOut}` (optional; for blank node support only)
                *   - `${navigateElementFilterIn}` (optional; for blank node support only)
                *
                * Expected bindings:
                *   - `?link` link type
                *   - `?inCount` incoming links count
                *   - `?outCount` outgoing links count
                */
            linkTypesStatisticsQuery: string;
            /**
                * when fetching all links from element, we could specify additional filter
                */
            filterRefElementLinkPattern: string;
            /**
                * SPARQL query pattern to retrieve transitive type sets for elements.
                *
                * Expected output bindings:
                *   - `?inst` element IRI
                *   - `?class` element type (there may be multiple or transitive types for an element)
                */
            filterTypePattern: string;
            /**
                * how to fetch elements info when fetching data.
                */
            filterElementInfoPattern: string;
            /**
                * imposes additional filtering on elements within filter
                */
            filterAdditionalRestriction: string;
            /**
                * Abstract links configuration - one could abstract a property path as a link on the diagram.
                */
            linkConfigurations: LinkConfiguration[];
            /**
                * (Experimental) Allows data provider to find links other than specified in `linkConfigurations`
                * when `linkConfigurations` has at least one value set.
                *
                * @default false
                */
            openWorldLinks?: boolean;
            /**
                * Abstract property configuration similar to abstract link configuration. Not type-specific yet.
                */
            propertyConfigurations: PropertyConfiguration[];
            /**
                * (Experimental) Allows data provider to find element properties other than specified in
                * `propertyConfigurations` when `propertyConfigurations` has at least one value set.
                *
                * @default false
                */
            openWorldProperties?: boolean;
    }
    /**
        * Full text search settings,
        * developer could use anything from search extensions of triplestore to regular expressions match
        * See wikidata and dbpedia examples for reusing full text search capabilities of Blazegraph and Virtuozo
        */
    export interface FullTextSearchSettings {
            /**
                * Prefixes to use in full text search queries.
                */
            prefix: string;
            /**
                * SPARQL query pattern to search/restrict results by text token.
                *
                * Parametrized variables:
                *   - `${text}` text token
                *   - `${dataLabelProperty}` `dataLabelProperty` property from the settings
                *
                * Expected bindings:
                *   - `?inst` link type
                *   - `?score` numerical score for ordering search results by relevance
                *   - `?extractedLabel` (optional; if `extractLabel` is enabled)
                */
            queryPattern: string;
            /**
                * When enabled, adds SPARQL patterns to try to extract label from IRI and
                * makes it available as `?extractedLabel` binding in `queryPattern`.
                */
            extractLabel?: boolean;
    }
    /**
        * Link abstraction configuration.
        */
    export interface LinkConfiguration {
            /**
                * IRI of the "virtual" link
                */
            id: string;
            /**
                * Optional domain constraint for source element of the link.
                * If specified checks RDF type of source element to match one from this set.
                */
            domain?: ReadonlyArray<string>;
            /**
                * SPARQL predicate or pattern connecting source element to target element.
                *
                * Expected bindings (if it is a pattern):
                *   - `?source` source element
                *   - `?target` target element
                *
                * @example
                * Direct configuration: `ex:relatedToOther`
                *
                * Pattern configuration: `
                *   ?source ex:hasAddress ?addr .
                *   ?addr ex:hasCountry ?target .
                *   OPTIONAL {
                *     BIND(ex:addressType as ?propType)
                *     ?addr ex:addressType ?propValue
                *   }
                * `
                */
            path: string;
            /**
                * Additional SPARQL patterns can be used for getting properties of the link.
                *
                * Expected bindings
                *   - `?source` source element
                *   - `?target` target element
                *   - `?propType` link property type
                *   - `?propValue` link property value
                */
            properties?: string;
    }
    /**
        * Specifies property abstraction configuration
        */
    export interface PropertyConfiguration {
            /**
                * IRI of the "virtual" link
                */
            id: string;
            /**
                * Optional domain constraint for source element of the property.
                * If specified checks RDF type of source element to match one from this set.
                */
            domain?: ReadonlyArray<string>;
            /**
                * SPARQL predicate or pattern connecting source element to property value.
                *
                * Expected bindings (if it is a pattern):
                *   - `?inst` source element
                *   - `?value` property value
                *
                * @example
                * Direct configuration: `ex:firstName`
                *
                * Pattern configuration: `
                *   ?inst ex:hasAddress ?addr .
                *   ?addr ex:hasApartmentNumber ?value
                * `
                */
            path: string;
    }
    export const RDFSettings: SparqlDataProviderSettings;
    export const WikidataSettings: SparqlDataProviderSettings;
    export const OWLRDFSSettingsOverride: Partial<SparqlDataProviderSettings>;
    export const OWLRDFSSettings: SparqlDataProviderSettings;
    export const OWLStatsSettings: SparqlDataProviderSettings;
    export const DBPediaSettings: SparqlDataProviderSettings;
}

declare module 'ontodia/ontodia/data/sparql/graphBuilder' {
    import { SerializedDiagram } from 'ontodia/ontodia/editor/serializedDiagram';
    import { Dictionary, ElementModel, LinkModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { DataProvider } from 'ontodia/ontodia/data/provider';
    import { Triple } from 'ontodia/ontodia/data/sparql/sparqlModels';
    export class GraphBuilder {
        dataProvider: DataProvider;
        constructor(dataProvider: DataProvider);
        createGraph(graph: {
            elementIds: ElementIri[];
            links: LinkModel[];
        }): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            diagram: SerializedDiagram;
        }>;
        getGraphFromRDFGraph(graph: Triple[]): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            diagram: SerializedDiagram;
        }>;
        getGraphFromTurtleGraph(graph: string): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            diagram: SerializedDiagram;
        }>;
    }
    export function makeGraphItems(response: ReadonlyArray<Triple>): {
        elementIds: ElementIri[];
        links: LinkModel[];
    };
    export function makeLayout(elementsIds: ReadonlyArray<ElementIri>, linksInfo: ReadonlyArray<LinkModel>): SerializedDiagram;
}

declare module 'ontodia/ontodia/data/sparql/sparqlGraphBuilder' {
    import { SerializedDiagram } from 'ontodia/ontodia/editor/serializedDiagram';
    import { Dictionary, ElementModel } from 'ontodia/ontodia/data/model';
    import { GraphBuilder } from 'ontodia/ontodia/data/sparql/graphBuilder';
    import { SparqlDataProvider } from 'ontodia/ontodia/data/sparql/sparqlDataProvider';
    export class SparqlGraphBuilder {
        dataProvider: SparqlDataProvider;
        graphBuilder: GraphBuilder;
        constructor(dataProvider: SparqlDataProvider);
        getGraphFromConstruct(constructQuery: string): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            diagram: SerializedDiagram;
        }>;
    }
}

declare module 'ontodia/ontodia/data/schema' {
    import { ElementTypeIri, LinkTypeIri } from 'ontodia/ontodia/data/model';
    export const DIAGRAM_CONTEXT_URL_V1 = "https://ontodia.org/context/v1.json";
    export const PLACEHOLDER_ELEMENT_TYPE: ElementTypeIri;
    export const PLACEHOLDER_LINK_TYPE: LinkTypeIri;
    export namespace GenerateID {
        function forElement(): string;
        function forLink(): string;
    }
    export namespace TemplateProperties {
        const PinnedProperties = "ontodia:pinnedProperties";
        const CustomLabel = "ontodia:customLabel";
    }
}

declare module 'ontodia/ontodia/diagram/commands' {
    import { ElementModel, ElementIri, LinkModel } from 'ontodia/ontodia/data/model';
    import { Element, Link, FatLinkType } from 'ontodia/ontodia/diagram/elements';
    import { Vector } from 'ontodia/ontodia/diagram/geometry';
    import { Command } from 'ontodia/ontodia/diagram/history';
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    export class RestoreGeometry implements Command {
        readonly title = "Move elements and links";
        constructor(elementState: ReadonlyArray<{
            element: Element;
            position: Vector;
        }>, linkState: ReadonlyArray<{
            link: Link;
            vertices: ReadonlyArray<Vector>;
        }>);
        static capture(model: DiagramModel): RestoreGeometry;
        hasChanges(): boolean;
        filterOutUnchanged(): RestoreGeometry;
        invoke(): RestoreGeometry;
    }
    export function restoreCapturedLinkGeometry(link: Link): Command;
    export function setElementExpanded(element: Element, expanded: boolean): Command;
    export function changeLinkTypeVisibility(params: {
        linkType: FatLinkType;
        visible: boolean;
        showLabel: boolean;
        preventLoading?: boolean;
    }): Command;
    export function setElementData(model: DiagramModel, target: ElementIri, data: ElementModel): Command;
    export function setLinkData(model: DiagramModel, oldData: LinkModel, newData: LinkModel): Command;
}

declare module 'ontodia/ontodia/diagram/elements' {
    import { ElementModel, LinkModel, LocalizedString, ElementIri, ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    import { Events, PropertyChange } from 'ontodia/ontodia/viewUtils/events';
    import { Vector, Size, Rect } from 'ontodia/ontodia/diagram/geometry';
    export type Cell = Element | Link | LinkVertex;
    export enum LinkDirection {
            in = "in",
            out = "out"
    }
    export interface ElementEvents {
            changeData: PropertyChange<Element, ElementModel>;
            changePosition: PropertyChange<Element, Vector>;
            changeSize: PropertyChange<Element, Size>;
            changeExpanded: PropertyChange<Element, boolean>;
            changeGroup: PropertyChange<Element, string>;
            changeElementState: PropertyChange<Element, ElementTemplateState | undefined>;
            requestedFocus: {
                    source: Element;
            };
            requestedGroupContent: {
                    source: Element;
            };
            requestedAddToFilter: {
                    source: Element;
                    linkType?: FatLinkType;
                    direction?: 'in' | 'out';
            };
            requestedRedraw: {
                    source: Element;
            };
    }
    export class Element {
            readonly events: Events<ElementEvents>;
            readonly id: string;
            /** All in and out links of the element */
            readonly links: Link[];
            constructor(props: {
                    id: string;
                    data: ElementModel;
                    position?: Vector;
                    size?: Size;
                    expanded?: boolean;
                    group?: string;
                    elementState?: ElementTemplateState;
                    temporary?: boolean;
            });
            get iri(): ElementIri;
            get data(): ElementModel;
            setData(value: ElementModel): void;
            get position(): Vector;
            setPosition(value: Vector): void;
            get size(): Size;
            setSize(value: Size): void;
            get isExpanded(): boolean;
            setExpanded(value: boolean): void;
            get group(): string | undefined;
            setGroup(value: string | undefined): void;
            get elementState(): ElementTemplateState | undefined;
            setElementState(value: ElementTemplateState | undefined): void;
            get temporary(): boolean;
            focus(): void;
            requestGroupContent(): void;
            addToFilter(linkType?: FatLinkType, direction?: 'in' | 'out'): void;
            redraw(): void;
    }
    export interface ElementTemplateState {
            [propertyIri: string]: any;
    }
    export interface AddToFilterRequest {
            element: Element;
            linkType?: FatLinkType;
            direction?: 'in' | 'out';
    }
    export interface FatClassModelEvents {
            changeLabel: PropertyChange<FatClassModel, ReadonlyArray<LocalizedString>>;
            changeCount: PropertyChange<FatClassModel, number | undefined>;
    }
    export class FatClassModel {
            readonly events: Events<FatClassModelEvents>;
            readonly id: ElementTypeIri;
            constructor(props: {
                    id: ElementTypeIri;
                    label?: ReadonlyArray<LocalizedString>;
                    count?: number;
            });
            get label(): readonly LocalizedString[];
            setLabel(value: ReadonlyArray<LocalizedString>): void;
            get count(): number;
            setCount(value: number | undefined): void;
    }
    export interface RichPropertyEvents {
            changeLabel: PropertyChange<RichProperty, ReadonlyArray<LocalizedString>>;
    }
    export class RichProperty {
            readonly events: Events<RichPropertyEvents>;
            readonly id: PropertyTypeIri;
            constructor(props: {
                    id: PropertyTypeIri;
                    label?: ReadonlyArray<LocalizedString>;
            });
            get label(): ReadonlyArray<LocalizedString>;
            setLabel(value: ReadonlyArray<LocalizedString>): void;
    }
    export interface LinkEvents {
            changeData: PropertyChange<Link, LinkModel>;
            changeLayoutOnly: PropertyChange<Link, boolean>;
            changeVertices: PropertyChange<Link, ReadonlyArray<Vector>>;
            changeLabelBounds: PropertyChange<Link, Rect>;
            changeLinkState: PropertyChange<Link, LinkTemplateState | undefined>;
    }
    export class Link {
            readonly events: Events<LinkEvents>;
            readonly id: string;
            constructor(props: {
                    id?: string;
                    typeId: LinkTypeIri;
                    sourceId: string;
                    targetId: string;
                    data?: LinkModel;
                    vertices?: ReadonlyArray<Vector>;
                    linkState?: LinkTemplateState;
            });
            get typeId(): LinkTypeIri;
            get sourceId(): string;
            get targetId(): string;
            get data(): LinkModel;
            setData(value: LinkModel | undefined): void;
            get labelBounds(): Rect;
            setLabelBounds(value: Rect | undefined): void;
            get layoutOnly(): boolean;
            setLayoutOnly(value: boolean): void;
            get vertices(): ReadonlyArray<Vector>;
            setVertices(value: ReadonlyArray<Vector>): void;
            get linkState(): LinkTemplateState | undefined;
            setLinkState(value: LinkTemplateState | undefined): void;
    }
    export interface LinkTemplateState {
            [propertyIri: string]: any;
    }
    export function linkMarkerKey(linkTypeIndex: number, startMarker: boolean): string;
    export interface FatLinkTypeEvents {
            changeLabel: PropertyChange<FatLinkType, ReadonlyArray<LocalizedString>>;
            changeIsNew: PropertyChange<FatLinkType, boolean>;
            changeVisibility: {
                    source: FatLinkType;
                    preventLoading: boolean;
            };
    }
    /**
        * Properties:
        *     visible: boolean
        *     showLabel: boolean
        *     isNew?: boolean
        *     label?: { values: LocalizedString[] }
        */
    export class FatLinkType {
            readonly events: Events<FatLinkTypeEvents>;
            readonly id: LinkTypeIri;
            constructor(props: {
                    id: LinkTypeIri;
                    index?: number;
                    label?: ReadonlyArray<LocalizedString>;
            });
            get index(): number;
            setIndex(value: number): void;
            get label(): readonly LocalizedString[];
            setLabel(value: ReadonlyArray<LocalizedString>): void;
            get visible(): boolean;
            get showLabel(): boolean;
            setVisibility(params: {
                    visible: boolean;
                    showLabel: boolean;
                    preventLoading?: boolean;
            }): void;
            get isNew(): boolean;
            setIsNew(value: boolean): void;
    }
    export class LinkVertex {
            readonly link: Link;
            readonly vertexIndex: number;
            constructor(link: Link, vertexIndex: number);
            createAt(location: Vector): void;
            moveTo(location: Vector): void;
            remove(): void;
    }
}

declare module 'ontodia/ontodia/diagram/embeddedLayer' {
    import * as React from 'react';
    import { PaperAreaContextWrapper } from 'ontodia/ontodia/diagram/paperArea';
    import { ElementContextWrapper } from 'ontodia/ontodia/diagram/elementLayer';
    export interface State {
        paperWidth?: number;
        paperHeight?: number;
        offsetX?: number;
        offsetY?: number;
    }
    export class EmbeddedLayer extends React.Component<{}, State> {
        static contextTypes: {
            ontodiaPaperArea: any;
            ontodiaElement: any;
        };
        context: ElementContextWrapper & PaperAreaContextWrapper;
        constructor(props: {});
        componentDidMount(): void;
        componentWillUnmount(): void;
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/diagram/geometry' {
    import { Element as DiagramElement } from 'ontodia/ontodia/diagram/elements';
    export interface Vector {
        readonly x: number;
        readonly y: number;
    }
    export namespace Vector {
        function equals(a: Vector, b: Vector): boolean;
        function length({ x, y }: Vector): number;
        function normalize({ x, y }: Vector): {
            x: number;
            y: number;
        };
        function dot({ x: x1, y: y1 }: Vector, { x: x2, y: y2 }: Vector): number;
        function cross2D({ x: x1, y: y1 }: Vector, { x: x2, y: y2 }: Vector): number;
    }
    export interface Size {
        readonly width: number;
        readonly height: number;
    }
    export interface Rect {
        readonly x: number;
        readonly y: number;
        readonly width: number;
        readonly height: number;
    }
    export namespace Rect {
        function center({ x, y, width, height }: Rect): {
            x: number;
            y: number;
        };
    }
    export function boundsOf(element: DiagramElement): Rect;
    export function isPolylineEqual(left: ReadonlyArray<Vector>, right: ReadonlyArray<Vector>): boolean;
    export function computePolyline(source: DiagramElement, target: DiagramElement, vertices: ReadonlyArray<Vector>): Vector[];
    export function computePolylineLength(polyline: ReadonlyArray<Vector>): number;
    export function getPointAlongPolyline(polyline: ReadonlyArray<Vector>, offset: number): Vector;
    export function findNearestSegmentIndex(polyline: ReadonlyArray<Vector>, location: Vector): number;
    export function computeGrouping(elements: ReadonlyArray<DiagramElement>): Map<string, DiagramElement[]>;
}

declare module 'ontodia/ontodia/diagram/history' {
    import { Events } from 'ontodia/ontodia/viewUtils/events';
    export interface Command {
        readonly title?: string;
        readonly invoke: CommandAction;
    }
    /** @returns Inverse command */
    export type CommandAction = () => Command;
    export namespace Command {
        function create(title: string, action: CommandAction): Command;
        function effect(title: string, body: () => void): Command;
    }
    export interface CommandHistoryEvents {
        historyChanged: {
            hasChanges: boolean;
        };
    }
    export interface CommandHistory {
        readonly events: Events<CommandHistoryEvents>;
        readonly undoStack: ReadonlyArray<Command>;
        readonly redoStack: ReadonlyArray<Command>;
        reset(): void;
        undo(): void;
        redo(): void;
        execute(command: Command): void;
        registerToUndo(command: Command): void;
        startBatch(title?: string): Batch;
    }
    export interface Batch {
        readonly history: CommandHistory;
        store(): void;
        discard(): void;
    }
    export class NonRememberingHistory implements CommandHistory {
        readonly events: Events<CommandHistoryEvents>;
        readonly undoStack: ReadonlyArray<Command>;
        readonly redoStack: ReadonlyArray<Command>;
        reset(): void;
        undo(): void;
        redo(): void;
        execute(command: Command): void;
        registerToUndo(command: Command): void;
        startBatch(title?: string): Batch;
    }
}

declare module 'ontodia/ontodia/diagram/model' {
    import { ElementModel, ElementIri, ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    import { EventSource, Events, EventObserver, AnyEvent } from 'ontodia/ontodia/viewUtils/events';
    import { Element, ElementEvents, Link, LinkEvents, FatLinkType, FatLinkTypeEvents, FatClassModel, FatClassModelEvents, RichProperty } from 'ontodia/ontodia/diagram/elements';
    import { Graph } from 'ontodia/ontodia/diagram/graph';
    import { CommandHistory } from 'ontodia/ontodia/diagram/history';
    export interface DiagramModelEvents {
        changeCells: {};
        elementEvent: AnyEvent<ElementEvents>;
        linkEvent: AnyEvent<LinkEvents>;
        linkTypeEvent: AnyEvent<FatLinkTypeEvents>;
        classEvent: AnyEvent<FatClassModelEvents>;
        changeGroupContent: {
            group: string;
        };
    }
    /**
      * Model of diagram.
      */
    export class DiagramModel {
        readonly history: CommandHistory;
        protected readonly source: EventSource<DiagramModelEvents>;
        readonly events: Events<DiagramModelEvents>;
        protected graph: Graph;
        protected graphListener: EventObserver;
        constructor(history: CommandHistory);
        get elements(): readonly Element[];
        get links(): readonly Link[];
        getElement(elementId: string): Element | undefined;
        getLinkById(linkId: string): Link | undefined;
        linksOfType(linkTypeId: LinkTypeIri): ReadonlyArray<Link>;
        findLink(linkTypeId: LinkTypeIri, sourceId: string, targetId: string): Link | undefined;
        sourceOf(link: Link): Element;
        targetOf(link: Link): Element;
        isSourceAndTargetVisible(link: Link): boolean;
        resetGraph(): void;
        subscribeGraph(): void;
        reorderElements(compare: (a: Element, b: Element) => number): void;
        createElement(elementIriOrModel: ElementIri | ElementModel, group?: string): Element;
        removeElement(elementId: string): void;
        addLink(link: Link): Link;
        removeLink(linkId: string): void;
        getClass(classIri: ElementTypeIri): FatClassModel;
        createClass(classIri: ElementTypeIri): FatClassModel;
        addClass(model: FatClassModel): void;
        getLinkType(linkTypeIri: LinkTypeIri): FatLinkType | undefined;
        createLinkType(linkTypeIri: LinkTypeIri): FatLinkType;
        getProperty(propertyTypeIri: PropertyTypeIri): RichProperty;
        createProperty(propertyIri: PropertyTypeIri): RichProperty;
        triggerChangeGroupContent(group: string): void;
        createTemporaryElement(): Element;
    }
    export function placeholderDataFromIri(iri: ElementIri): ElementModel;
}

declare module 'ontodia/ontodia/diagram/view' {
    import { ReactNode } from 'react';
    import { ReactElement, MouseEvent } from 'react';
    import { LinkRouter, TypeStyleResolver, LinkTemplateResolver, TemplateResolver, ElementTemplate, LinkTemplate, RoutedLink, RoutedLinks } from 'ontodia/ontodia/customization/props';
    import { ElementModel, LocalizedString, ElementTypeIri, LinkTypeIri } from 'ontodia/ontodia/data/model';
    import { Events, PropertyChange } from 'ontodia/ontodia/viewUtils/events';
    import { Element, Link, FatLinkType } from 'ontodia/ontodia/diagram/elements';
    import { Vector } from 'ontodia/ontodia/diagram/geometry';
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    export enum IriClickIntent {
        JumpToEntity = "jumpToEntity",
        OpenEntityIri = "openEntityIri",
        OpenOtherIri = "openOtherIri"
    }
    export interface IriClickEvent {
        iri: string;
        element: Element;
        clickIntent: IriClickIntent;
        originalEvent: MouseEvent<any>;
    }
    export type IriClickHandler = (event: IriClickEvent) => void;
    export type LabelLanguageSelector = (labels: ReadonlyArray<LocalizedString>, language: string) => LocalizedString | undefined;
    export interface ViewOptions {
        typeStyleResolver?: TypeStyleResolver;
        linkTemplateResolver?: LinkTemplateResolver;
        elementTemplateResolver?: TemplateResolver;
        selectLabelLanguage?: LabelLanguageSelector;
        linkRouter?: LinkRouter;
        onIriClick?: IriClickHandler;
    }
    export interface TypeStyle {
        color: {
            h: number;
            c: number;
            l: number;
        };
        icon?: string;
    }
    export enum RenderingLayer {
        Element = 1,
        ElementSize = 2,
        PaperArea = 3,
        Link = 4,
        Editor = 5,
        FirstToUpdate = 1,
        LastToUpdate = 5
    }
    export interface DiagramViewEvents {
        changeLanguage: PropertyChange<DiagramView, string>;
        changeLinkTemplates: {};
        syncUpdate: {
            layer: RenderingLayer;
        };
        updateWidgets: UpdateWidgetsEvent;
        dispose: {};
        changeHighlight: PropertyChange<DiagramView, Highlighter>;
        updateRoutings: PropertyChange<DiagramView, RoutedLinks>;
    }
    export interface UpdateWidgetsEvent {
        widgets: {
            [key: string]: WidgetDescription;
        };
    }
    export enum WidgetAttachment {
        Viewport = 1,
        OverElements = 2,
        OverLinks = 3
    }
    export interface WidgetDescription {
        element: ReactElement<any>;
        attachment: WidgetAttachment;
    }
    export interface DropOnPaperEvent {
        dragEvent: DragEvent;
        paperPosition: Vector;
    }
    export type Highlighter = ((item: Element | Link) => boolean) | undefined;
    export type ElementDecoratorResolver = (element: Element) => ReactNode | undefined;
    export class DiagramView {
        readonly model: DiagramModel;
        readonly options: ViewOptions;
        readonly events: Events<DiagramViewEvents>;
        constructor(model: DiagramModel, options?: ViewOptions);
        getRoutings(): RoutedLinks;
        getRouting(linkId: string): RoutedLink;
        getLanguage(): string;
        setLanguage(value: string): void;
        getLinkTemplates(): ReadonlyMap<LinkTypeIri, LinkTemplate>;
        performSyncUpdate(): void;
        onIriClick(iri: string, element: Element, clickIntent: IriClickIntent, event: React.MouseEvent<any>): void;
        setPaperWidget(widget: {
            key: string;
            widget: ReactElement<any> | undefined;
            attachment: WidgetAttachment;
        }): void;
        setHandlerForNextDropOnPaper(handler: (e: DropOnPaperEvent) => void): void;
        _tryHandleDropOnPaper(e: DropOnPaperEvent): boolean;
        selectLabel(labels: ReadonlyArray<LocalizedString>, language?: string): LocalizedString | undefined;
        formatLabel(labels: ReadonlyArray<LocalizedString>, fallbackIri: string, language?: string): string;
        getElementTypeString(elementModel: ElementModel): string;
        getTypeStyle(types: ElementTypeIri[]): TypeStyle;
        formatIri(iri: string): string;
        getElementTemplate(types: ElementTypeIri[]): ElementTemplate;
        createLinkTemplate(linkType: FatLinkType): LinkTemplate;
        dispose(): void;
        get highlighter(): (item: Element | Link) => boolean;
        setHighlighter(value: Highlighter): void;
        _setElementDecorator(decorator: ElementDecoratorResolver): void;
        _decorateElement(element: Element): ReactNode | undefined;
    }
}

declare module 'ontodia/ontodia/diagram/paperArea' {
    import * as React from 'react';
    import { Events, PropertyChange } from 'ontodia/ontodia/viewUtils/events';
    import { ToDataURLOptions } from 'ontodia/ontodia/viewUtils/toSvg';
    import { Element, Link, Cell } from 'ontodia/ontodia/diagram/elements';
    import { Vector, Rect } from 'ontodia/ontodia/diagram/geometry';
    import { DiagramView, WidgetDescription } from 'ontodia/ontodia/diagram/view';
    import { PaperTransform } from 'ontodia/ontodia/diagram/paper';
    export interface PaperAreaProps {
            view: DiagramView;
            zoomOptions?: ZoomOptions;
            hideScrollBars?: boolean;
            watermarkSvg?: string;
            watermarkUrl?: string;
            onDragDrop?: (e: DragEvent, paperPosition: {
                    x: number;
                    y: number;
            }) => void;
            onZoom?: (scaleX: number, scaleY: number) => void;
    }
    export interface ZoomOptions {
            min?: number;
            max?: number;
            step?: number;
            /** Used when zooming to fit to limit zoom of small diagrams */
            maxFit?: number;
            fitPadding?: number;
            requireCtrl?: boolean;
    }
    export interface PaperAreaEvents {
            pointerDown: PointerEvent;
            pointerMove: PointerEvent;
            pointerUp: PointerUpEvent;
            scroll: {
                    source: PaperArea;
            };
            changeAnimatingGraph: PropertyChange<PaperArea, boolean>;
    }
    export interface PointerEvent {
            source: PaperArea;
            sourceEvent: React.MouseEvent<Element> | MouseEvent;
            target: Cell | undefined;
            panning: boolean;
    }
    export interface PointerUpEvent extends PointerEvent {
            triggerAsClick: boolean;
    }
    export interface PaperWidgetProps {
            paperArea?: PaperArea;
            paperTransform?: PaperTransform;
    }
    export interface State {
            readonly paperWidth?: number;
            readonly paperHeight?: number;
            readonly originX?: number;
            readonly originY?: number;
            readonly scale?: number;
            readonly paddingX?: number;
            readonly paddingY?: number;
            readonly renderedWidgets?: ReadonlyArray<WidgetDescription>;
    }
    export interface PaperAreaContextWrapper {
            ontodiaPaperArea: PaperAreaContext;
    }
    export interface PaperAreaContext {
            paperArea: PaperArea;
            view: DiagramView;
    }
    export const PaperAreaContextTypes: {
            [K in keyof PaperAreaContextWrapper]: any;
    };
    interface ViewportState {
            /** Center of the viewport in paper coordinates. */
            readonly center: Vector;
            readonly scale: Vector;
    }
    export interface ViewportOptions {
            /**
                * True if operation should be animated.
                * If duration is not provided assumes default one.
                */
            animate?: boolean;
            /**
                * Animation duration in milliseconds.
                * Implicitly sets `animate: true` if greater than zero.
                */
            duration?: number;
            /**
                * Elements to apply layout and zoomToFit operations.
                * (In other words we narrowing down viewPort to selected elements)
                */
            elements?: ReadonlySet<Element>;
    }
    export interface ScaleOptions extends ViewportOptions {
            pivot?: {
                    x: number;
                    y: number;
            };
    }
    export class PaperArea extends React.Component<PaperAreaProps, State> {
            static childContextTypes: {
                    ontodiaPaperArea: any;
            };
            readonly events: Events<PaperAreaEvents>;
            constructor(props: PaperAreaProps, context: any);
            getChildContext(): PaperAreaContextWrapper;
            render(): JSX.Element;
            componentDidMount(): void;
            componentDidUpdate(prevProps: PaperAreaProps, prevState: State): void;
            componentWillUnmount(): void;
            pageToPaperCoords(pageX: number, pageY: number): {
                    x: number;
                    y: number;
            };
            clientToPaperCoords(areaClientX: number, areaClientY: number): {
                    x: number;
                    y: number;
            };
            clientToScrollablePaneCoords(areaClientX: number, areaClientY: number): {
                    x: number;
                    y: number;
            };
            scrollablePaneToPaperCoords(paneX: number, paneY: number): {
                    x: number;
                    y: number;
            };
            paperToScrollablePaneCoords(paperX: number, paperY: number): {
                    x: number;
                    y: number;
            };
            /** Returns bounding box of paper content in paper coordinates. */
            getContentFittingBox(): {
                    x: number;
                    y: number;
                    width: number;
                    height: number;
            };
            /** Returns paper size in paper coordinates. */
            getPaperSize(): {
                    width: number;
                    height: number;
            };
            getAreaMetrics(): {
                    clientWidth: number;
                    clientHeight: number;
                    offsetWidth: number;
                    offsetHeight: number;
            };
            adjustPaper: (callback?: () => void) => void;
            centerTo(paperPosition?: {
                    x: number;
                    y: number;
            }, options?: ViewportOptions): Promise<void>;
            centerContent(options?: ViewportOptions): Promise<void>;
            getScale(): number;
            setScale(value: number, options?: ScaleOptions): Promise<void>;
            zoomBy(value: number, options?: ScaleOptions): Promise<void>;
            zoomIn(scaleOptions?: ScaleOptions): Promise<void>;
            zoomOut(scaleOptions?: ScaleOptions): Promise<void>;
            zoomToFit(options?: ViewportOptions): Promise<void>;
            zoomToFitRect(bbox: Rect, options?: ViewportOptions): Promise<void>;
            exportSVG(): Promise<string>;
            exportPNG(options: ToDataURLOptions): Promise<string>;
            isAnimatingGraph(): boolean;
            /**
                * Starts animation for graph elements and links.
                *
                * @param setupChanges immediately called function to perform animatable changes on graph
                * @param duration animation duration in milliseconds (requires custom CSS to override)
                * @returns promise which resolves when this animation ends
                */
            animateGraph(setupChanges: () => void, duration?: number): Promise<void>;
            applyViewportState: (targetState: ViewportState) => void;
    }
    export function getContentFittingBox(elements: ReadonlyArray<Element>, links: ReadonlyArray<Link>): {
            x: number;
            y: number;
            width: number;
            height: number;
    };
    export {};
}

declare module 'ontodia/ontodia/editor/asyncModel' {
    import { Dictionary, ElementModel, LinkModel, ElementIri, LinkTypeIri, ElementTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    import { DataProvider } from 'ontodia/ontodia/data/provider';
    import { FatLinkType, FatClassModel, RichProperty } from 'ontodia/ontodia/diagram/elements';
    import { CommandHistory, Command } from 'ontodia/ontodia/diagram/history';
    import { DiagramModel, DiagramModelEvents } from 'ontodia/ontodia/diagram/model';
    import { Events } from 'ontodia/ontodia/viewUtils/events';
    import { SerializedDiagram } from 'ontodia/ontodia/editor/serializedDiagram';
    export interface GroupBy {
        linkType: string;
        linkDirection: 'in' | 'out';
    }
    export interface AsyncModelEvents extends DiagramModelEvents {
        loadingStart: {
            source: AsyncModel;
        };
        loadingSuccess: {
            source: AsyncModel;
        };
        loadingError: {
            source: AsyncModel;
            error: any;
        };
        createLoadedLink: {
            source: AsyncModel;
            model: LinkModel;
            cancel(): void;
        };
    }
    export class AsyncModel extends DiagramModel {
        readonly events: Events<AsyncModelEvents>;
        constructor(history: CommandHistory, groupByProperties: ReadonlyArray<GroupBy>);
        get dataProvider(): DataProvider;
        subscribeGraph(): void;
        createNewDiagram(dataProvider: DataProvider): Promise<void>;
        importLayout(params: {
            dataProvider: DataProvider;
            preloadedElements?: Dictionary<ElementModel>;
            validateLinks?: boolean;
            diagram?: SerializedDiagram;
            hideUnusedLinkTypes?: boolean;
        }): Promise<void>;
        exportLayout(): SerializedDiagram;
        requestElementData(elementIris: ReadonlyArray<ElementIri>): Promise<void>;
        requestLinksOfType(linkTypeIds?: LinkTypeIri[]): Promise<void>;
        createClass(classId: ElementTypeIri): FatClassModel;
        createLinkType(linkTypeId: LinkTypeIri): FatLinkType;
        createProperty(propertyIri: PropertyTypeIri): RichProperty;
        createLinks(data: LinkModel): void;
        loadEmbeddedElements(elementIri: ElementIri): Promise<Dictionary<ElementModel>>;
    }
    export function requestElementData(model: AsyncModel, elementIris: ReadonlyArray<ElementIri>): Command;
    export function restoreLinksBetweenElements(model: AsyncModel): Command;
}

declare module 'ontodia/ontodia/editor/authoredEntity' {
    import * as React from 'react';
    import { TemplateProps } from 'ontodia/ontodia/customization/props';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    import { PaperAreaContextWrapper } from 'ontodia/ontodia/diagram/paperArea';
    import { WorkspaceContextWrapper } from 'ontodia/ontodia/workspace/workspaceContext';
    import { EditorController } from 'ontodia/ontodia/editor/editorController';
    export interface AuthoredEntityProps {
        templateProps: TemplateProps;
        children: (context: AuthoredEntityContext) => React.ReactElement<any>;
    }
    export interface AuthoredEntityContext {
        editor: EditorController;
        editedIri?: string;
        view: DiagramView;
        canEdit: boolean | undefined;
        canDelete: boolean | undefined;
        onEdit: () => void;
        onDelete: () => void;
    }
    export interface State {
        canEdit?: boolean;
        canDelete?: boolean;
    }
    /**
      * Component to simplify tracking changes in validation messages (property and link type labels).
      */
    export class AuthoredEntity extends React.Component<AuthoredEntityProps, State> {
        static contextTypes: {
            ontodiaWorkspace: any;
            ontodiaPaperArea: any;
        };
        context: PaperAreaContextWrapper & WorkspaceContextWrapper;
        constructor(props: AuthoredEntityProps, context: any);
        componentDidMount(): void;
        componentDidUpdate(prevProps: AuthoredEntityProps): void;
        componentWillUnmount(): void;
        render(): React.ReactElement<any>;
    }
}

declare module 'ontodia/ontodia/editor/authoringState' {
    import { ElementModel, LinkModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { HashMap, ReadonlyHashMap } from 'ontodia/ontodia/viewUtils/collections';
    export interface AuthoringState {
        readonly elements: ReadonlyMap<ElementIri, ElementChange>;
        readonly links: ReadonlyHashMap<LinkModel, LinkChange>;
    }
    export type AuthoringEvent = ElementChange | LinkChange;
    export enum AuthoringKind {
        ChangeElement = "changeElement",
        ChangeLink = "changeLink"
    }
    export interface ElementChange {
        readonly type: AuthoringKind.ChangeElement;
        readonly before?: ElementModel;
        readonly after: ElementModel;
        readonly newIri?: ElementIri;
        readonly deleted: boolean;
    }
    export interface LinkChange {
        readonly type: AuthoringKind.ChangeLink;
        readonly before?: LinkModel;
        readonly after: LinkModel;
        readonly deleted: boolean;
    }
    interface MutableAuthoringState extends AuthoringState {
        readonly elements: Map<ElementIri, ElementChange>;
        readonly links: HashMap<LinkModel, LinkChange>;
    }
    export namespace AuthoringState {
        const empty: AuthoringState;
        function isEmpty(state: AuthoringState): boolean;
        function clone(index: AuthoringState): MutableAuthoringState;
        function has(state: AuthoringState, event: AuthoringEvent): boolean;
        function discard(state: AuthoringState, discarded: AuthoringEvent): AuthoringState;
        function addElement(state: AuthoringState, item: ElementModel): AuthoringState;
        function addLink(state: AuthoringState, item: LinkModel): AuthoringState;
        function changeElement(state: AuthoringState, before: ElementModel, after: ElementModel): AuthoringState;
        function changeLink(state: AuthoringState, before: LinkModel, after: LinkModel): AuthoringState;
        function deleteElement(state: AuthoringState, model: ElementModel): AuthoringState;
        function deleteLink(state: AuthoringState, target: LinkModel): AuthoringState;
        function deleteNewLinksConnectedToElements(state: AuthoringState, elementIris: Set<ElementIri>): AuthoringState;
        function isNewElement(state: AuthoringState, target: ElementIri): boolean;
        function isDeletedElement(state: AuthoringState, target: ElementIri): boolean;
        function isElementWithModifiedIri(state: AuthoringState, target: ElementIri): boolean;
        function isNewLink(state: AuthoringState, linkModel: LinkModel): boolean;
        function isDeletedLink(state: AuthoringState, linkModel: LinkModel): boolean;
        function isUncertainLink(state: AuthoringState, linkModel: LinkModel): boolean;
    }
    export interface TemporaryState {
        readonly elements: ReadonlyMap<ElementIri, ElementModel>;
        readonly links: ReadonlyHashMap<LinkModel, LinkModel>;
    }
    export namespace TemporaryState {
        const empty: TemporaryState;
        function addElement(state: TemporaryState, element: ElementModel): {
            elements: Map<ElementIri, ElementModel>;
            links: ReadonlyHashMap<LinkModel, LinkModel>;
        };
        function deleteElement(state: TemporaryState, element: ElementModel): {
            elements: Map<ElementIri, ElementModel>;
            links: ReadonlyHashMap<LinkModel, LinkModel>;
        };
        function addLink(state: TemporaryState, link: LinkModel): {
            links: HashMap<LinkModel, LinkModel>;
            elements: ReadonlyMap<ElementIri, ElementModel>;
        };
        function deleteLink(state: TemporaryState, link: LinkModel): {
            links: HashMap<LinkModel, LinkModel>;
            elements: ReadonlyMap<ElementIri, ElementModel>;
        };
    }
    export function isLinkConnectedToElement(link: LinkModel, elementIri: ElementIri): boolean;
    export {};
}

declare module 'ontodia/ontodia/editor/editorController' {
    import * as React from 'react';
    import { MetadataApi } from 'ontodia/ontodia/data/metadataApi';
    import { ValidationApi } from 'ontodia/ontodia/data/validationApi';
    import { ElementModel, LinkModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { Element, Link, FatLinkType } from 'ontodia/ontodia/diagram/elements';
    import { Vector } from 'ontodia/ontodia/diagram/geometry';
    import { PaperArea } from 'ontodia/ontodia/diagram/paperArea';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    import { Events, PropertyChange } from 'ontodia/ontodia/viewUtils/events';
    import { PropertySuggestionHandler } from 'ontodia/ontodia/widgets/connectionsMenu';
    import { SpinnerProps } from 'ontodia/ontodia/viewUtils/spinner';
    import { AsyncModel } from 'ontodia/ontodia/editor/asyncModel';
    import { AuthoringState, AuthoringEvent, TemporaryState } from 'ontodia/ontodia/editor/authoringState';
    import { ValidationState } from 'ontodia/ontodia/editor/validation';
    export interface PropertyEditorOptions {
        elementData: ElementModel;
        onSubmit: (newData: ElementModel) => void;
        onCancel?: () => void;
    }
    export type PropertyEditor = (options: PropertyEditorOptions) => React.ReactElement<any>;
    export enum DialogTypes {
        ConnectionsMenu = 0,
        EditEntityForm = 1,
        EditLinkForm = 2,
        EditEntityTypeForm = 3,
        EditLinkLabelForm = 4
    }
    export type SelectionItem = Element | Link;
    export interface EditorProps extends EditorOptions {
        model: AsyncModel;
        view: DiagramView;
    }
    export interface EditorOptions {
        disableHalo?: boolean;
        suggestProperties?: PropertySuggestionHandler;
        validationApi?: ValidationApi;
        propertyEditor?: PropertyEditor;
    }
    export interface EditorEvents {
        changeMode: {
            source: EditorController;
        };
        changeSelection: PropertyChange<EditorController, ReadonlyArray<SelectionItem>>;
        changeAuthoringState: PropertyChange<EditorController, AuthoringState>;
        changeValidationState: PropertyChange<EditorController, ValidationState>;
        changeTemporaryState: PropertyChange<EditorController, TemporaryState>;
        toggleDialog: {
            isOpened: boolean;
        };
        addElements: {
            elements: ReadonlyArray<Element>;
        };
    }
    export class EditorController {
        readonly events: Events<EditorEvents>;
        readonly model: AsyncModel;
        constructor(props: EditorProps);
        _initializePaperComponents(paperArea: PaperArea): void;
        get inAuthoringMode(): boolean;
        get metadataApi(): MetadataApi;
        setMetadataApi(value: MetadataApi): void;
        get authoringState(): AuthoringState;
        setAuthoringState(value: AuthoringState): void;
        get validationState(): ValidationState;
        setValidationState(value: ValidationState): void;
        get temporaryState(): TemporaryState;
        setTemporaryState(value: TemporaryState): void;
        get selection(): readonly (Element | Link)[];
        setSelection(value: ReadonlyArray<SelectionItem>): void;
        cancelSelection(): void;
        removeSelectedElements(): void;
        removeItems(items: ReadonlyArray<SelectionItem>): void;
        setSpinner(props: SpinnerProps | undefined): void;
        showConnectionsMenu(target: Element): void;
        showEditEntityForm(target: Element): void;
        showEditElementTypeForm({ link, source, target }: {
            link: Link;
            source: Element;
            target: Element;
        }): void;
        showEditLinkForm(link: Link): void;
        showDialog(params: {
            target: SelectionItem;
            dialogType: DialogTypes;
            content: React.ReactElement<any>;
            size?: {
                width: number;
                height: number;
            };
            caption?: string;
            offset?: Vector;
            calculatePosition?: () => Vector;
            onClose: () => void;
        }): void;
        hideDialog(): void;
        onDragDrop(dragged: ReadonlyArray<ElementIri | ElementModel>, paperPosition: Vector): void;
        onAddElementsInConnectionMenu(elementIris: ElementIri[], targetElement: Element, linkType: FatLinkType | undefined): void;
        createNewEntity({ elementModel, temporary }: {
            elementModel: ElementModel;
            temporary?: boolean;
        }): Element;
        changeEntityData(targetIri: ElementIri, newData: ElementModel): void;
        deleteEntity(elementIri: ElementIri): void;
        createNewLink({ link: base, temporary }: {
            link: Link;
            temporary?: boolean;
        }): Link;
        changeLink(oldData: LinkModel, newData: LinkModel): void;
        moveLinkSource(params: {
            link: Link;
            newSource: Element;
        }): Link;
        moveLinkTarget(params: {
            link: Link;
            newTarget: Element;
        }): Link;
        deleteLink(model: LinkModel): void;
        finishEditing(): void;
        discardChange(event: AuthoringEvent): void;
    }
    export function createLinkAndChangeDirection({ data, originalData, sourceId, targetId }: {
        data: LinkModel;
        originalData: LinkModel;
        sourceId: string;
        targetId: string;
    }): Link;
}

declare module 'ontodia/ontodia/editor/validation' {
    import { ElementIri, LinkModel } from 'ontodia/ontodia/data/model';
    import { ValidationApi, ElementError, LinkError } from 'ontodia/ontodia/data/validationApi';
    import { CancellationToken } from 'ontodia/ontodia/viewUtils/async';
    import { HashMap, ReadonlyHashMap } from 'ontodia/ontodia/viewUtils/collections';
    import { AuthoringState } from 'ontodia/ontodia/editor/authoringState';
    import { EditorController } from 'ontodia/ontodia/editor/editorController';
    export interface ValidationState {
        readonly elements: ReadonlyMap<ElementIri, ElementValidation>;
        readonly links: ReadonlyHashMap<LinkModel, LinkValidation>;
    }
    export interface ElementValidation {
        readonly loading: boolean;
        readonly errors: ReadonlyArray<ElementError>;
    }
    export interface LinkValidation {
        readonly loading: boolean;
        readonly errors: ReadonlyArray<LinkError>;
    }
    export namespace ValidationState {
        const empty: ValidationState;
        const emptyElement: ElementValidation;
        const emptyLink: LinkValidation;
        function createMutable(): {
            elements: Map<ElementIri, ElementValidation>;
            links: HashMap<LinkModel, LinkValidation>;
        };
        function setElementErrors(state: ValidationState, target: ElementIri, errors: ReadonlyArray<ElementError>): ValidationState;
        function setLinkErrors(state: ValidationState, target: LinkModel, errors: ReadonlyArray<LinkError>): ValidationState;
    }
    export function changedElementsToValidate(previousAuthoring: AuthoringState, editor: EditorController): Set<ElementIri>;
    export function validateElements(targets: ReadonlySet<ElementIri>, validationApi: ValidationApi, editor: EditorController, cancellation: CancellationToken): void;
}

declare module 'ontodia/ontodia/editor/serializedDiagram' {
    import { ElementIri, LinkTypeIri } from 'ontodia/ontodia/data/model';
    import { Element, ElementTemplateState, Link, LinkTemplateState } from 'ontodia/ontodia/diagram/elements';
    import { Vector, Size } from 'ontodia/ontodia/diagram/geometry';
    export interface SerializedDiagram {
        '@context': any;
        '@type': 'Diagram';
        layoutData: LayoutData;
        linkTypeOptions?: ReadonlyArray<LinkTypeOptions>;
    }
    export interface LinkTypeOptions {
        '@type': 'LinkTypeOptions';
        property: LinkTypeIri;
        visible: boolean;
        showLabel?: boolean;
    }
    export interface LayoutData {
        '@type': 'Layout';
        elements: ReadonlyArray<LayoutElement>;
        links: ReadonlyArray<LayoutLink>;
    }
    export interface LayoutElement {
        '@type': 'Element';
        '@id': string;
        iri: ElementIri;
        position: Vector;
        size?: Size;
        angle?: number;
        isExpanded?: boolean;
        group?: string;
        elementState?: ElementTemplateState;
    }
    export interface LayoutLink {
        '@type': 'Link';
        '@id': string;
        property: LinkTypeIri;
        source: {
            '@id': string;
        };
        target: {
            '@id': string;
        };
        vertices?: ReadonlyArray<Vector>;
        linkState?: LinkTemplateState;
    }
    export function emptyDiagram(): SerializedDiagram;
    export function emptyLayoutData(): LayoutData;
    export function convertToSerializedDiagram(params: {
        layoutData: any;
        linkTypeOptions: any;
    }): SerializedDiagram;
    export function makeSerializedDiagram(params: {
        layoutData?: LayoutData;
        linkTypeOptions?: ReadonlyArray<LinkTypeOptions>;
    }): SerializedDiagram;
    export function makeLayoutData(modelElements: ReadonlyArray<Element>, modelLinks: ReadonlyArray<Link>): LayoutData;
}

declare module 'ontodia/ontodia/viewUtils/layout' {
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { Vector } from 'ontodia/ontodia/diagram/geometry';
    import { Element } from 'ontodia/ontodia/diagram/elements';
    export interface LayoutNode {
        id?: string;
        x: number;
        y: number;
        width: number;
        height: number;
        bounds?: any;
        fixed?: number;
        innerBounds?: any;
    }
    export interface LayoutLink {
        source: LayoutNode;
        target: LayoutNode;
    }
    export function groupForceLayout(params: {
        nodes: LayoutNode[];
        links: LayoutLink[];
        preferredLinkLength: number;
        avoidOvelaps?: boolean;
    }): void;
    export function groupRemoveOverlaps(nodes: LayoutNode[]): void;
    export function translateToPositiveQuadrant(positions: Map<string, Vector>, offset: Vector): void;
    export function uniformGrid(params: {
        rows: number;
        cellSize: Vector;
    }): (cellIndex: number) => LayoutNode;
    export function padded(nodes: LayoutNode[], padding: {
        x: number;
        y: number;
    } | undefined, transform: () => void): void;
    export function biasFreePadded(nodes: LayoutNode[], padding: {
        x: number;
        y: number;
    } | undefined, transform: () => void): void;
    export type CalculatedLayout = object & {
        readonly layoutBrand: void;
    };
    export interface UnzippedCalculatedLayout extends CalculatedLayout {
        group?: string;
        keepAveragePosition: boolean;
        positions: Map<string, Vector>;
        nestedLayouts: UnzippedCalculatedLayout[];
    }
    export function calculateLayout(params: {
        model: DiagramModel;
        layoutFunction: (nodes: LayoutNode[], links: LayoutLink[], group: string) => void;
        fixedElements?: ReadonlySet<Element>;
        group?: string;
        selectedElements?: ReadonlySet<Element>;
    }): CalculatedLayout;
    export function applyLayout(model: DiagramModel, layout: CalculatedLayout): void;
    export function calculateAveragePosition(position: ReadonlyArray<Element>): Vector;
    export function placeElementsAround(params: {
        model: DiagramModel;
        elements: ReadonlyArray<Element>;
        prefferedLinksLength: number;
        targetElement: Element;
        startAngle?: number;
    }): Promise<unknown>;
    export function removeOverlaps(params: {
        model: DiagramModel;
        fixedElements?: ReadonlySet<Element>;
        padding?: Vector;
        group?: string;
        selectedElements?: ReadonlySet<Element>;
    }): CalculatedLayout;
    export function forceLayout(params: {
        model: DiagramModel;
        fixedElements?: ReadonlySet<Element>;
        group?: string;
        selectedElements?: ReadonlySet<Element>;
    }): CalculatedLayout;
    export function getContentFittingBoxForLayout(nodes: ReadonlyArray<LayoutNode>): {
        x: number;
        y: number;
        width: number;
        height: number;
    };
}

declare module 'ontodia/ontodia/viewUtils/async' {
    export abstract class BatchingScheduler {
        readonly waitingTime: number;
        constructor(waitingTime?: number);
        protected schedule(): void;
        protected abstract run(): void;
        runSynchronously(): void;
        dispose(): void;
    }
    export class BufferingQueue<Key extends string> extends BatchingScheduler {
        constructor(onFetch: (keys: Key[]) => void, waitingTime?: number);
        push(key: Key): void;
        clear(): void;
        protected run(): void;
    }
    export class Debouncer extends BatchingScheduler {
        call(callback: () => void): void;
        protected run(): void;
    }
    export class Cancellation {
        static NEVER_SIGNAL: CancellationToken;
        readonly signal: CancellationToken;
        constructor();
        abort(): void;
    }
    export interface CancellationToken {
        readonly aborted: boolean;
        addEventListener(event: 'abort', handler: () => void): void;
        removeEventListener(event: 'abort', handler: () => void): void;
    }
    export class CancelledError extends Error {
        constructor(message: string);
    }
    export function delay(timeout: number): Promise<unknown>;
    export function animateInterval(duration: number, onProgress: (progress: number) => void, cancellation?: Cancellation): Promise<void>;
    export function easeInOutBezier(t: number): number;
}

declare module 'ontodia/ontodia/viewUtils/events' {
    export type Listener<Data, Key extends keyof Data> = (data: Data[Key], key: Key) => void;
    export type AnyListener<Data> = (data: Partial<Data>, key: string) => void;
    export type Unsubscribe = () => void;
    export interface PropertyChange<Source, Value> {
        source: Source;
        previous: Value;
    }
    export interface AnyEvent<Data> {
        key: string;
        data: Partial<Data>;
    }
    export interface Events<Data> {
        on<Key extends keyof Data>(eventKey: Key, listener: Listener<Data, Key>): void;
        off<Key extends keyof Data>(eventKey: Key, listener: Listener<Data, Key>): void;
        onAny(listener: AnyListener<Data>): void;
        offAny(listener: AnyListener<Data>): void;
    }
    export class EventSource<Data> implements Events<Data> {
        on<Key extends keyof Data>(eventKey: Key, listener: Listener<Data, Key>): void;
        onAny(listener: AnyListener<Data>): void;
        off<Key extends keyof Data>(eventKey: Key, listener: Listener<Data, Key>): void;
        offAny(listener: AnyListener<Data>): void;
        trigger<Key extends keyof Data>(eventKey: Key, data: Data[Key]): void;
    }
    export class EventObserver {
        listen<Data, Key extends keyof Data>(events: Events<Data>, eventKey: Key, listener: Listener<Data, Key>): void;
        listenAny<Data>(events: Events<Data>, listener: AnyListener<Data>): void;
        listenOnce<Data, Key extends keyof Data>(events: Events<Data>, eventKey: Key, listener: Listener<Data, Key>): void;
        stopListening(): void;
    }
}

declare module 'ontodia/ontodia/widgets/connectionsMenu' {
    import * as React from 'react';
    import { Dictionary, ElementModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { FatLinkType, Element } from 'ontodia/ontodia/diagram/elements';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    import { EditorController } from 'ontodia/ontodia/editor/editorController';
    import { WorkspaceContextWrapper } from 'ontodia/ontodia/workspace/workspaceContext';
    export interface ReactElementModel {
        model: ElementModel;
        presentOnDiagram: boolean;
    }
    export interface PropertySuggestionParams {
        elementId: string;
        token: string;
        properties: string[];
        lang: string;
    }
    export type PropertySuggestionHandler = (params: PropertySuggestionParams) => Promise<Dictionary<PropertyScore>>;
    export interface PropertyScore {
        propertyIri: string;
        score: number;
    }
    export interface LinkDataChunk {
        link: FatLinkType;
        direction?: 'in' | 'out';
        expectedCount: number;
        offset?: number;
    }
    export interface ObjectsData {
        linkDataChunk: LinkDataChunk;
        objects: ReactElementModel[];
    }
    export interface ConnectionsMenuProps {
        view: DiagramView;
        editor: EditorController;
        target: Element;
        onClose: () => void;
        onAddElements: (elementIris: ElementIri[], linkType: FatLinkType | undefined) => void;
        suggestProperties?: PropertySuggestionHandler;
    }
    export class ConnectionsMenu extends React.Component<ConnectionsMenuProps, {}> {
        static contextTypes: {
            ontodiaWorkspace: any;
        };
        readonly context: WorkspaceContextWrapper;
        componentDidMount(): void;
        componentWillUnmount(): void;
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/workspace/toolbar' {
    import * as React from 'react';
    import { WorkspaceLanguage } from 'ontodia/ontodia/workspace/workspace';
    export interface ToolbarProps {
        canSaveDiagram?: boolean;
        onSaveDiagram?: () => void;
        canPersistChanges?: boolean;
        onPersistChanges?: () => void;
        onForceLayout?: () => void;
        onClearAll?: () => void;
        onZoomIn?: () => void;
        onZoomOut?: () => void;
        onZoomToFit?: () => void;
        onExportSVG?: (fileName?: string) => void;
        onExportPNG?: (fileName?: string) => void;
        onPrint?: () => void;
        languages?: ReadonlyArray<WorkspaceLanguage>;
        selectedLanguage?: string;
        onChangeLanguage?: (language: string) => void;
        hidePanels?: boolean;
    }
    export class DefaultToolbar extends React.Component<ToolbarProps, {}> {
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/workspace/workspace' {
    import { Component, ReactElement } from 'react';
    import { LinkRouter, LinkTemplateResolver, TemplateResolver, TypeStyleResolver } from 'ontodia/ontodia/customization/props';
    import { MetadataApi } from 'ontodia/ontodia/data/metadataApi';
    import { ValidationApi } from 'ontodia/ontodia/data/validationApi';
    import { Rect } from 'ontodia/ontodia/diagram/geometry';
    import { CommandHistory } from 'ontodia/ontodia/diagram/history';
    import { PaperArea, ZoomOptions, PointerEvent, PointerUpEvent } from 'ontodia/ontodia/diagram/paperArea';
    import { DiagramView, IriClickHandler, LabelLanguageSelector } from 'ontodia/ontodia/diagram/view';
    import { AsyncModel, GroupBy } from 'ontodia/ontodia/editor/asyncModel';
    import { EditorController, PropertyEditor } from 'ontodia/ontodia/editor/editorController';
    import { PropertySuggestionHandler } from 'ontodia/ontodia/widgets/connectionsMenu';
    import { SearchCriteria } from 'ontodia/ontodia/widgets/instancesSearch';
    import { WorkspaceEventHandler } from 'ontodia/ontodia/workspace/workspaceContext';
    export interface WorkspaceProps {
            /** Saves diagram layout (position and state of elements and links). */
            onSaveDiagram?: (workspace: Workspace) => void;
            /** Persists authored changes in the editor. */
            onPersistChanges?: (workspace: Workspace) => void;
            onPointerDown?: (e: PointerEvent) => void;
            onPointerMove?: (e: PointerEvent) => void;
            onPointerUp?: (e: PointerUpEvent) => void;
            /**
                * Custom toolbar to replace the default one.
                */
            toolbar?: ReactElement<any>;
            /** @default false */
            hidePanels?: boolean;
            /** @default false */
            hideToolbar?: boolean;
            /** @default false */
            hideScrollBars?: boolean;
            /** @default false */
            hideHalo?: boolean;
            /** @default true */
            hideTutorial?: boolean;
            /** @default false */
            hideNavigator?: boolean;
            /** @default false */
            collapseNavigator?: boolean;
            /** @default true */
            leftPanelInitiallyOpen?: boolean;
            /** @default false */
            rightPanelInitiallyOpen?: boolean;
            /**
                * Set of languages to display diagram data.
                */
            languages?: ReadonlyArray<WorkspaceLanguage>;
            /**
                * Currently selected language.
                */
            language?: string;
            /**
                * Called when user selected another language from the UI.
                *
                * If this function is set, language selection will work in controlled mode;
                * otherwise language selection will function in uncontrolled mode.
                */
            onLanguageChange?: (language: string) => void;
            zoomOptions?: ZoomOptions;
            onZoom?: (scaleX: number, scaleY: number) => void;
            history?: CommandHistory;
            viewOptions?: DiagramViewOptions;
            /**
                * If provided, switches editor into "authoring mode".
                */
            metadataApi?: MetadataApi;
            validationApi?: ValidationApi;
            propertyEditor?: PropertyEditor;
            onWorkspaceEvent?: WorkspaceEventHandler;
            /**
                * Custom panel to search existing elements on the diagram.
                */
            _elementsSearchPanel?: ReactElement<any>;
            typeStyleResolver?: TypeStyleResolver;
            linkTemplateResolver?: LinkTemplateResolver;
            elementTemplateResolver?: TemplateResolver;
            /**
                * Overrides label selection based on target language.
                */
            selectLabelLanguage?: LabelLanguageSelector;
    }
    export interface DiagramViewOptions {
            linkRouter?: LinkRouter;
            onIriClick?: IriClickHandler;
            groupBy?: GroupBy[];
            disableDefaultHalo?: boolean;
            suggestProperties?: PropertySuggestionHandler;
    }
    export interface WorkspaceLanguage {
            code: string;
            label: string;
    }
    export interface WorkspaceState {
            readonly criteria?: SearchCriteria;
    }
    export class Workspace extends Component<WorkspaceProps, WorkspaceState> {
            static readonly defaultProps: Partial<WorkspaceProps>;
            constructor(props: WorkspaceProps);
            _getPaperArea(): PaperArea | undefined;
            _setWatermark(watermarkSvg: string | undefined, watermarkUrl: string | undefined): void;
            render(): ReactElement<any>;
            componentDidMount(): void;
            componentWillReceiveProps(nextProps: WorkspaceProps): void;
            componentWillUnmount(): void;
            getModel(): AsyncModel;
            getDiagram(): DiagramView;
            getEditor(): EditorController;
            preventTextSelectionUntilMouseUp(): void;
            zoomToFit: () => Promise<void>;
            zoomToFitRect: (bbox: Rect) => void;
            clearAll: () => void;
            showWaitIndicatorWhile(operation: Promise<any>): void;
            forceLayout: () => void;
            exportSvg: (fileName?: string) => void;
            exportPng: (fileName?: string) => void;
            undo: () => void;
            redo: () => void;
            zoomBy: (value: number) => void;
            zoomIn: () => void;
            zoomOut: () => void;
            print: () => void;
            changeLanguage: (language: string) => void;
            centerTo: (paperPosition?: {
                    x: number;
                    y: number;
            }) => void;
    }
    export function renderTo<WorkspaceComponentProps>(workspace: React.ComponentClass<WorkspaceComponentProps>, container: HTMLElement, props: WorkspaceComponentProps): void;
}

declare module 'ontodia/ontodia/workspace/workspaceContext' {
    import { EditorController } from 'ontodia/ontodia/editor/editorController';
    export type WorkspaceEventHandler = (key: WorkspaceEventKey) => void;
    export enum WorkspaceEventKey {
        searchUpdateCriteria = "search:updateCriteria",
        searchQueryItem = "search:queryItems",
        connectionsLoadLinks = "connections:loadLinks",
        connectionsExpandLink = "connections:expandLink",
        connectionsLoadElements = "connections:loadElements",
        editorChangeSelection = "editor:changeSelection",
        editorToggleDialog = "editor:toggleDialog",
        editorAddElements = "editor:addElements"
    }
    export interface WorkspaceContextWrapper {
        ontodiaWorkspace: WorkspaceContext;
    }
    export interface WorkspaceContext {
        editor: EditorController;
        triggerWorkspaceEvent: WorkspaceEventHandler;
    }
    export const WorkspaceContextTypes: {
        [K in keyof WorkspaceContextWrapper]: any;
    };
}

declare module 'ontodia/ontodia/workspace/draggableHandle' {
    import * as React from 'react';
    export interface Props extends React.HTMLAttributes<HTMLDivElement> {
        onBeginDragHandle: (e: React.MouseEvent<HTMLDivElement>) => void;
        onDragHandle: (e: MouseEvent, dx: number, dy: number) => void;
        onEndDragHandle?: (e: MouseEvent) => void;
    }
    export class DraggableHandle extends React.Component<Props, {}> {
        render(): JSX.Element;
        componentWillUnmount(): void;
    }
}

declare module 'ontodia/ontodia/workspace/layout/layout' {
    import * as React from 'react';
    export enum WorkspaceLayoutType {
        Row = "row",
        Column = "column",
        Component = "component"
    }
    export type WorkspaceLayoutNode = Container | Component;
    interface Container {
        type: WorkspaceLayoutType.Row | WorkspaceLayoutType.Column;
        children: ReadonlyArray<WorkspaceLayoutNode>;
        defaultSize?: number;
        defaultCollapsed?: boolean;
        collapsedSize?: number;
        minSize?: number;
        undocked?: boolean;
        animationDuration?: number;
    }
    interface Component {
        id: string;
        type: WorkspaceLayoutType.Component;
        content: React.ReactElement<any>;
        heading?: React.ReactNode;
        defaultSize?: number;
        defaultCollapsed?: boolean;
        collapsedSize?: number;
        minSize?: number;
        undocked?: boolean;
    }
    export interface WorkspaceLayoutProps {
        layout: WorkspaceLayoutNode;
        _onStartResize?: (direction: 'vertical' | 'horizontal') => void;
        _onResize?: (direction: 'vertical' | 'horizontal') => void;
    }
    export class WorkspaceLayout extends React.Component<WorkspaceLayoutProps, {}> {
        render(): JSX.Element;
    }
    export {};
}

declare module 'ontodia/internalApi' {
    export { LINK_SHOW_IRI } from 'ontodia/ontodia/customization/defaultLinkStyles';
    export { TemplateProperties } from 'ontodia/ontodia/data/schema';
    export * from 'ontodia/ontodia/diagram/paper';
    export * from 'ontodia/ontodia/diagram/paperArea';
    export * from 'ontodia/ontodia/viewUtils/async';
    export * from 'ontodia/ontodia/viewUtils/collections';
    export * from 'ontodia/ontodia/viewUtils/keyedObserver';
    export * from 'ontodia/ontodia/viewUtils/spinner';
    export * from 'ontodia/ontodia/widgets/listElementView';
    export * from 'ontodia/ontodia/widgets/searchResults';
    export { WorkspaceContext, WorkspaceContextWrapper, WorkspaceContextTypes, } from 'ontodia/ontodia/workspace/workspaceContext';
    export { groupForceLayout, groupRemoveOverlaps, padded, biasFreePadded, getContentFittingBoxForLayout, } from 'ontodia/ontodia/viewUtils/layout';
}

declare module 'ontodia/ontodia/customization/templates/default' {
    import * as React from 'react';
    import { TemplateProps } from 'ontodia/ontodia/customization/props';
    export class DefaultElementTemplate extends React.Component<TemplateProps, {}> {
        render(): JSX.Element;
        renderPropertyTable(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/customization/templates/group' {
    import * as React from 'react';
    import { TemplateProps } from 'ontodia/ontodia/customization/props';
    export class GroupTemplate extends React.Component<TemplateProps, {}> {
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/customization/templates/standard' {
    import { Component } from 'react';
    import { TemplateProps } from 'ontodia/ontodia/customization/props';
    export class StandardTemplate extends Component<TemplateProps, {}> {
        render(): JSX.Element;
        protected getTypesLabel(): string;
    }
}

declare module 'ontodia/ontodia/diagram/elementLayer' {
    import * as React from 'react';
    import { TemplateProps } from 'ontodia/ontodia/customization/props';
    import { Element } from 'ontodia/ontodia/diagram/elements';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    export interface Props {
        view: DiagramView;
        group?: string;
        style: React.CSSProperties;
    }
    interface State {
        readonly elementStates?: ReadonlyMap<string, ElementState>;
    }
    interface ElementState {
        element: Element;
        templateProps: TemplateProps;
        blurred: boolean;
    }
    export class ElementLayer extends React.Component<Props, State> {
        constructor(props: Props, context: any);
        render(): JSX.Element;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: Props): void;
        componentWillUnmount(): void;
    }
    export interface ElementContextWrapper {
        ontodiaElement: ElementContext;
    }
    export const ElementContextTypes: {
        [K in keyof ElementContextWrapper]: any;
    };
    export interface ElementContext {
        element: Element;
    }
    export {};
}

declare module 'ontodia/ontodia/diagram/graph' {
    import { ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    import { Events, AnyEvent } from 'ontodia/ontodia/viewUtils/events';
    import { Element as DiagramElement, ElementEvents, Link as DiagramLink, LinkEvents, FatLinkType, FatLinkTypeEvents, FatClassModel, FatClassModelEvents, RichProperty } from 'ontodia/ontodia/diagram/elements';
    export interface GraphEvents {
        changeCells: {};
        elementEvent: AnyEvent<ElementEvents>;
        linkEvent: AnyEvent<LinkEvents>;
        linkTypeEvent: AnyEvent<FatLinkTypeEvents>;
        classEvent: AnyEvent<FatClassModelEvents>;
    }
    export class Graph {
        readonly events: Events<GraphEvents>;
        getElements(): readonly DiagramElement[];
        getLinks(): readonly DiagramLink[];
        getLink(linkId: string): DiagramLink | undefined;
        findLink(linkTypeId: LinkTypeIri, sourceId: string, targetId: string): DiagramLink | undefined;
        sourceOf(link: DiagramLink): DiagramElement;
        targetOf(link: DiagramLink): DiagramElement;
        reorderElements(compare: (a: DiagramElement, b: DiagramElement) => number): void;
        getElement(elementId: string): DiagramElement | undefined;
        addElement(element: DiagramElement): void;
        removeElement(elementId: string): void;
        addLink(link: DiagramLink): void;
        removeLink(linkId: string, options?: {
            silent?: boolean;
        }): void;
        getLinkTypes(): FatLinkType[];
        getLinkType(linkTypeId: LinkTypeIri): FatLinkType | undefined;
        addLinkType(linkType: FatLinkType): void;
        getProperty(propertyId: PropertyTypeIri): RichProperty | undefined;
        addProperty(property: RichProperty): void;
        getClass(classId: ElementTypeIri): FatClassModel | undefined;
        getClasses(): FatClassModel[];
        addClass(classModel: FatClassModel): void;
    }
}

declare module 'ontodia/ontodia/viewUtils/toSvg' {
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { Rect } from 'ontodia/ontodia/diagram/geometry';
    export interface ToSVGOptions {
            model: DiagramModel;
            paper: SVGSVGElement;
            contentBox: Rect;
            getOverlayedElement: (id: string) => HTMLElement;
            preserveDimensions?: boolean;
            convertImagesToDataUris?: boolean;
            blacklistedCssAttributes?: string[];
            elementsToRemoveSelector?: string;
            mockImages?: boolean;
            watermarkSvg?: string;
    }
    export function toSVG(options: ToSVGOptions): Promise<string>;
    export interface ToDataURLOptions {
            /** 'image/png' | 'image/jpeg' | ... */
            mimeType?: string;
            width?: number;
            height?: number;
            /** Background color, transparent by default. */
            backgroundColor?: string;
            quality?: number;
    }
    export function toDataURL(options: ToSVGOptions & ToDataURLOptions): Promise<string>;
    export function loadImage(source: string): Promise<HTMLImageElement>;
    export function fitRectKeepingAspectRatio(sourceWidth: number, sourceHeight: number, targetWidth: number | undefined, targetHeight: number | undefined): {
            width: number;
            height: number;
    };
    /**
        * Creates and returns a blob from a data URL (either base64 encoded or not).
        *
        * @param {string} dataURL The data URL to convert.
        * @return {Blob} A blob representing the array buffer data.
        */
    export function dataURLToBlob(dataURL: string): Blob;
}

declare module 'ontodia/ontodia/diagram/paper' {
    import * as React from 'react';
    import { Component } from 'react';
    import { Cell } from 'ontodia/ontodia/diagram/elements';
    import { Vector } from 'ontodia/ontodia/diagram/geometry';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    export interface PaperProps {
            view: DiagramView;
            paperTransform: PaperTransform;
            onPointerDown?: (e: React.MouseEvent<HTMLElement>, cell: Cell | undefined) => void;
            group?: string;
            linkLayerWidgets?: React.ReactElement<any>;
            elementLayerWidgets?: React.ReactElement<any>;
    }
    export class Paper extends Component<PaperProps, {}> {
            render(): JSX.Element;
    }
    export interface PaperTransform {
            width: number;
            height: number;
            originX: number;
            originY: number;
            scale: number;
            paddingX: number;
            paddingY: number;
    }
    export interface TransformedSvgCanvasProps extends React.HTMLProps<SVGSVGElement> {
            paperTransform: PaperTransform;
    }
    export class TransformedSvgCanvas extends Component<TransformedSvgCanvasProps, {}> {
            render(): JSX.Element;
    }
    /**
        * @returns scrollable pane size in non-scaled pane coords.
        */
    export function totalPaneSize(pt: PaperTransform): Vector;
    /**
        * @returns scrollable pane top-left corner position in non-scaled pane coords.
        */
    export function paneTopLeft(pt: PaperTransform): Vector;
    export function paneFromPaperCoords(paper: Vector, pt: PaperTransform): Vector;
    export function paperFromPaneCoords(pane: Vector, pt: PaperTransform): Vector;
}

declare module 'ontodia/ontodia/viewUtils/collections' {
    export function createStringMap<V>(): {
            [key: string]: V;
    };
    export function createNumberMap<V>(): {
            [key: number]: V;
    };
    export function hasOwnProperty(collection: object, key: string | number): boolean;
    export function objectValues<T>(obj: {
            [key: string]: T;
    }): T[];
    export function isEmptyMap(map: object): boolean;
    /**
        * Clones Map collection. Required due to IE11 not supporing `new Map(map)`.
        */
    export function cloneMap<K, V>(map: ReadonlyMap<K, V>): Map<K, V>;
    /**
        * Clones Set collection. Required due to IE11 not supporing `new Set(set)`.
        */
    export function cloneSet<T>(set: ReadonlySet<T>): Set<T>;
    export function getOrCreateArrayInMap<K, V>(map: Map<K, V[]>, key: K): V[];
    export function getOrCreateSetInMap<K, V>(map: Map<K, Set<V>>, key: K): Set<V>;
    export class OrderedMap<V> {
            constructor();
            reorder(compare: (a: V, b: V) => number): void;
            get items(): ReadonlyArray<V>;
            get(key: string): V | undefined;
            push(key: string, value: V): void;
            delete(key: string): V | undefined;
    }
    export interface ReadonlyHashMap<K, V> {
            readonly size: number;
            has(key: K): boolean;
            get(key: K): V | undefined;
            forEach(callback: (value: V, key: K, map: ReadonlyHashMap<K, V>) => void): void;
            clone(): HashMap<K, V>;
    }
    export class HashMap<K, V> implements ReadonlyHashMap<K, V> {
            constructor(hashCode: (key: K) => number, equals: (k1: K, k2: K) => boolean);
            get size(): number;
            has(key: K): boolean;
            get(key: K): V | undefined;
            set(key: K, value: V): this;
            delete(key: K): boolean;
            clear(): void;
            forEach(callback: (value: V, key: K, map: HashMap<K, V>) => void): void;
            clone(): HashMap<K, V>;
    }
    export enum MoveDirection {
            ToStart = -1,
            ToEnd = 1
    }
    export function makeMoveComparator<T>(items: ReadonlyArray<T>, selected: ReadonlyArray<T>, moveDirection: MoveDirection): (a: T, b: T) => number;
}

declare module 'ontodia/ontodia/viewUtils/spinner' {
    import * as React from 'react';
    export interface SpinnerProps {
        size?: number;
        position?: {
            x: number;
            y: number;
        };
        maxWidth?: number;
        statusText?: string;
        errorOccured?: boolean;
    }
    export class Spinner extends React.Component<SpinnerProps, {}> {
        render(): JSX.Element;
    }
    export class HtmlSpinner extends React.Component<{
        width: number;
        height: number;
    }, {}> {
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/widgets/instancesSearch' {
    import * as React from 'react';
    import { ElementModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { FilterParams } from 'ontodia/ontodia/data/provider';
    import { Element as DiagramElement, FatLinkType, FatClassModel } from 'ontodia/ontodia/diagram/elements';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    import { AsyncModel } from 'ontodia/ontodia/editor/asyncModel';
    import { WorkspaceContextWrapper } from 'ontodia/ontodia/workspace/workspaceContext';
    export interface InstancesSearchProps {
        className?: string;
        model: AsyncModel;
        view: DiagramView;
        criteria: SearchCriteria;
        onCriteriaChanged: (criteria: SearchCriteria) => void;
    }
    export interface SearchCriteria {
        readonly text?: string;
        readonly elementType?: FatClassModel;
        readonly refElement?: DiagramElement;
        readonly refElementLink?: FatLinkType;
        readonly linkDirection?: 'in' | 'out';
    }
    export interface State {
        readonly inputText?: string;
        readonly quering?: boolean;
        readonly resultId?: number;
        readonly error?: any;
        readonly items?: ReadonlyArray<ElementModel>;
        readonly selection?: ReadonlySet<ElementIri>;
        readonly moreItemsAvailable?: boolean;
    }
    export class InstancesSearch extends React.Component<InstancesSearchProps, State> {
        static contextTypes: {
            ontodiaWorkspace: any;
        };
        readonly context: WorkspaceContextWrapper;
        constructor(props: InstancesSearchProps, context: any);
        render(): JSX.Element;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: InstancesSearchProps): void;
        componentWillUnmount(): void;
    }
    export function createRequest(criteria: SearchCriteria, language: string): FilterParams;
}

declare module 'ontodia/ontodia/customization/defaultLinkStyles' {
    import { LinkTemplate, LinkTemplateResolver } from 'ontodia/ontodia/customization/props';
    export const LINK_SHOW_IRI: LinkTemplate;
    export const DefaultLinkTemplateBundle: LinkTemplateResolver;
}

declare module 'ontodia/ontodia/viewUtils/keyedObserver' {
    import { ElementTypeIri, LinkTypeIri, PropertyTypeIri } from 'ontodia/ontodia/data/model';
    import { FatClassModelEvents, FatLinkTypeEvents, RichPropertyEvents } from 'ontodia/ontodia/diagram/elements';
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { Unsubscribe, Listener } from 'ontodia/ontodia/viewUtils/events';
    export class KeyedObserver<Key extends string> {
        readonly subscribe: (key: Key) => Unsubscribe | undefined;
        constructor(subscribe: (key: Key) => Unsubscribe | undefined);
        observe(keys: ReadonlyArray<Key>): void;
        stopListening(): void;
    }
    export function observeElementTypes<Event extends keyof FatClassModelEvents>(model: DiagramModel, event: Event, listener: Listener<FatClassModelEvents, Event>): KeyedObserver<ElementTypeIri>;
    export function observeProperties<Event extends keyof RichPropertyEvents>(model: DiagramModel, event: Event, listener: Listener<RichPropertyEvents, Event>): KeyedObserver<PropertyTypeIri>;
    export function observeLinkTypes<Event extends keyof FatLinkTypeEvents>(model: DiagramModel, event: Event, listener: Listener<FatLinkTypeEvents, Event>): KeyedObserver<LinkTypeIri>;
}

declare module 'ontodia/ontodia/widgets/listElementView' {
    import * as React from 'react';
    import { ElementModel } from 'ontodia/ontodia/data/model';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    export interface ListElementViewProps {
        className?: string;
        view: DiagramView;
        model: ElementModel;
        highlightText?: string;
        disabled?: boolean;
        selected?: boolean;
        onClick?: (event: React.MouseEvent<any>, model: ElementModel) => void;
        onDragStart?: React.HTMLProps<HTMLElement>['onDragStart'];
    }
    export class ListElementView extends React.Component<ListElementViewProps, {}> {
        render(): JSX.Element;
    }
    export function startDragElements(e: React.DragEvent<{}>, iris: ReadonlyArray<string>): boolean;
    export function highlightSubstring(text: string, substring: string | undefined, highlightProps?: React.HTMLProps<HTMLSpanElement>): JSX.Element;
}

declare module 'ontodia/ontodia/widgets/searchResults' {
    import * as React from 'react';
    import { ElementModel, ElementIri } from 'ontodia/ontodia/data/model';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    export interface SearchResultProps {
        view: DiagramView;
        items: ReadonlyArray<ElementModel>;
        selection: ReadonlySet<ElementIri>;
        onSelectionChanged: (newSelection: ReadonlySet<ElementIri>) => void;
        highlightText?: string;
        /** @default true */
        useDragAndDrop?: boolean;
    }
    export class SearchResults extends React.Component<SearchResultProps, {}> {
        static defaultProps: Partial<SearchResultProps>;
        constructor(props: SearchResultProps);
        render(): React.ReactElement<any>;
        componentDidMount(): void;
        componentWillReceiveProps(props: SearchResultProps): void;
        componentWillUnmount(): void;
    }
}

